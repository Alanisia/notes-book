<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [数据结构与算法](#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95)
  - [线性数据结构](#%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)
    - [数组](#%E6%95%B0%E7%BB%84)
    - [栈](#%E6%A0%88)
    - [队列](#%E9%98%9F%E5%88%97)
    - [链表](#%E9%93%BE%E8%A1%A8)
    - [哈希表](#%E5%93%88%E5%B8%8C%E8%A1%A8)
    - [堆](#%E5%A0%86)
  - [非线性数据结构](#%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)
    - [树](#%E6%A0%91)
    - [二叉树](#%E4%BA%8C%E5%8F%89%E6%A0%91)
      - [二叉搜索树](#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91)
      - [AVL](#avl)
      - [红黑树](#%E7%BA%A2%E9%BB%91%E6%A0%91)
      - [树堆](#%E6%A0%91%E5%A0%86)
    - [B树](#b%E6%A0%91)
      - [B+树](#b%E6%A0%91)
    - [图](#%E5%9B%BE)
  - [算法](#%E7%AE%97%E6%B3%95)
    - [排序算法](#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)
    - [查找算法](#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95)
    - [算法策略](#%E7%AE%97%E6%B3%95%E7%AD%96%E7%95%A5)
      - [分治](#%E5%88%86%E6%B2%BB)
      - [动态规划](#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)
      - [贪心](#%E8%B4%AA%E5%BF%83)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 数据结构与算法

## 线性数据结构

### 数组

按照顺序存储在内存的连续空间内，每个数据的内存地址都可以通过数组下标计算得出，从而可以直接访问目标数据，达到随机访问的目的。

应用场景：

- 数据比较少
- 经常做的运算是按序号访问数据元素
- 构建稳定的线性表

### 栈

先进后出、后进先出的数据结构。

***TODO***

### 队列

先进先出的数据结构。

***TODO***

### 链表

物理存储单元上的非连续、非顺序的存储结构，由一系列节点组成，所谓节点就是指链表中的每个元素，每个节点都包含有存储元素的数据域和存储上/下一个节点地址的指针域。

应用场景：

- 对线性表的长度或规模难以估计
- 频繁做插入、删除操作
- 构造动态性比较强的线性表

### 哈希表

又称散列表，存储的是由键和值组成的数据，根据键直接访问存储在内存存储位置的数据结构。

散列函数/哈希函数：H = f(key)

***TODO***

冲突解决方法：

1. 开放定址法：
    1. 再哈希法：***TODO***
    2. 线性探测法：***TODO***
    3. 二次探测法：***TODO***
2. 链地址法：当某项关键字hash后落到哈希表中的某个位置，就把该条数据添加进某个位置下的链表中，其他同样映射到这个位置的数据项也只需要添加到链表中，不需要在原始数组中寻找空位来存储。

### 堆

可用于实现优先队列，满足以下条件的树形结构可称为堆：

1. 一个完全二叉树；
2. 堆中的每个节点的值都必须大于等于或小于等于其子树中每个节点的值。

如果每一节点都小于子树中每个节点的值，唤作小顶堆；反之则唤作大顶堆。

## 非线性数据结构

### 树

一种层级式的数据结构，由顶点（节点）和它们连接的边组成，其结构特点为：

- 每个节点有零个或多个子节点；
- 没有父节点的节点唤作根节点；
- 每个非根节点有且只有一个父节点；
- 除根节点外每个节点可以分为多个不相交的子树。

### 二叉树

特点：

- 每个节点最多有两棵子树，节点的度最大为2；
- 左子树和右子树是有顺序的，次序不能颠倒；
- 即使某节点只有一个子树亦须区分左右子树。

#### 二叉搜索树

***TODO***

#### AVL

***TODO***

#### 红黑树

特征：

- 每个节点非黑即红
- 根节点总是黑色
- 若节点是红色，则子节点必为黑色（反之不一定）
- 每个叶子节点都是黑色
- 任意节点到叶子节点或者空节点的每条路径必须包含相同数量的黑色节点（黑色节点深度相同） 

#### 树堆

***TODO***

### B树

一棵m阶B树至少包含如下特征：

- 根节点至少有两个子女
- 每个中间节点都包含`k-1`个元素和`k`个孩子，其中`m/2 <= k <= m`
- 每个叶子节点都包含`k-1`个元素，其中`m/2 <= k <= m`
- 所有叶子节点都位于同一层
- 每个节点中的元素从小到大排列，节点当中`k-1`个元素正好是`k`个孩子包含的元素的值域分划

#### B+树

一棵m阶的B+树具有如下特征：

- 有`k`个子树的中间节点包含有`k`个元素，每个元素不保存数据，只用来索引，所有数据都保存在叶子节点
- 所有的叶子节点中包含了全部元素的信息，以及指向含这些元素记录的指针，且叶子节点本身依关键字的大小自小而大顺序连接
- 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素

相比B树，B+树的优势：

- 单一节点存储更多的元素，使得查询I/O次数更少
- 所有查询都要查找到叶子节点，查询性能稳定
- 所有叶子节点形成有序链表，便于范围查询

### 图

***TODO***

## 算法

### 排序算法

- 冒泡排序（稳定排序）

    在最优情况下（正序）只需经过n-1次比较即可得出结果，最坏情况下（倒序或一个较小值在最后），下沉算法将需要n(n-1)/2次比较。
- 选择排序（不稳定排序）

    比较次数一定为n(n-1)/2次，虽然比较次数多，但数据交换量却很少，一般情况下快于冒泡排序。
- 直接插入排序（稳定排序）

    简单插入排序，每次比较后最多移掉一个逆序，因此与冒泡排序效率相同，但在速度上稍快于冒泡排序，在冒泡排序下进行值交换，插入排序下进行值移动；有序情况下只需经过n-1次比较，最坏情况下将需要n(n-1)/2次比较。
- 希尔排序（不稳定排序）

    增量的选择将影响希尔排序的效率，但无论怎样选择增量，最后一定使增量为1，进行一次直接插入排序，由于在子表中每进行一次比较，就可能移去整个子表的多个逆序，从而改善了整个排序性能。
- 归并排序（稳定排序）

    非就地排序，需要与待排序序列一样多的辅助空间，其时间复杂度无论在最好情况下或最坏情况下均是O(nlogn)；若数据量大不适合使用该算法，但可以考虑改造成索引操作。
- 快速排序（不稳定排序）

    对冒泡排序的改进，一次交换能消除多个逆序，减少逆序时所消耗的扫描和数据交换次数，最优情况下的时间复杂度为O(nlogn)，即每次划分字串时能均匀分成两个子串，最差情况下时间复杂度为O(n^2)，即每次划分字串时一串为空，另一串为m-1。倘若每次能均匀划分序列，将使其为最快速排序算法，即使很难均匀划分，就平均性能而言其仍是基于关键字比较的内部排序算法中速度最快者。
- 计数排序 

    ***TODO***
- 堆排序（不稳定排序）

    在直接选择排序的基础上利用了比较结果形成，效率提高很大，其时间复杂度为O(nlogn)。堆排序需要二步骤：一者建堆，二者排序（调整堆）。一般在小规模序列中不合适，但对于较大的序列将表现出优越的性能。
- 基数排序（稳定排序）

    在程序中采用的是以数值的十进制位分解，然后对空间采用一次性分配，需要较多辅助空间（10n+10，但可以进行分解，如以一个字节分解，空间采用链表将只需辅助空间n+256），其时间复杂度为O(n)。非就地排序，若节点数量大时宜改为索引排序，进行基数排序的前提是关键字能像整型、字符串那样能分解，若浮点型则不能使用基数排序。

### 查找算法

- 二分查找

    ***TODO***

### 算法策略

#### 分治

***TODO***

#### 动态规划

***TODO***

#### 贪心

***TODO***