<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>计算机网络 - Notes</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">README</a></li><li class="chapter-item expanded "><a href="../basis.html"><strong aria-hidden="true">1.</strong> 基础</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basis/DataStructuresAndAlgorithms.html"><strong aria-hidden="true">1.1.</strong> 数据结构与算法</a></li><li class="chapter-item expanded "><a href="../basis/OS.html"><strong aria-hidden="true">1.2.</strong> 操作系统</a></li><li class="chapter-item expanded "><a href="../basis/Network.html" class="active"><strong aria-hidden="true">1.3.</strong> 计算机网络</a></li><li class="chapter-item expanded "><a href="../basis/Project.html"><strong aria-hidden="true">1.4.</strong> 项目管理</a></li></ol></li><li class="chapter-item expanded "><a href="../java.html"><strong aria-hidden="true">2.</strong> Java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../java/JavaSE.html"><strong aria-hidden="true">2.1.</strong> 基础</a></li><li class="chapter-item expanded "><a href="../java/Collections.html"><strong aria-hidden="true">2.2.</strong> 集合</a></li><li class="chapter-item expanded "><a href="../java/Concurrent.html"><strong aria-hidden="true">2.3.</strong> 并发</a></li><li class="chapter-item expanded "><a href="../java/JVM.html"><strong aria-hidden="true">2.4.</strong> 虚拟机</a></li><li class="chapter-item expanded "><a href="../java/IO.html"><strong aria-hidden="true">2.5.</strong> 输入输出</a></li><li class="chapter-item expanded "><a href="../java/Frameworks.html"><strong aria-hidden="true">2.6.</strong> 框架</a></li><li class="chapter-item expanded "><a href="../java/DesignPatterns.html"><strong aria-hidden="true">2.7.</strong> 设计模式</a></li><li class="chapter-item expanded "><a href="../java/BigData.html"><strong aria-hidden="true">2.8.</strong> 大数据</a></li></ol></li><li class="chapter-item expanded "><a href="../database/Database.html"><strong aria-hidden="true">3.</strong> 数据库</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../database/SQL.html"><strong aria-hidden="true">3.1.</strong> SQL</a></li><li class="chapter-item expanded "><a href="../database/MySQL.html"><strong aria-hidden="true">3.2.</strong> MySQL</a></li></ol></li><li class="chapter-item expanded "><a href="../Linux.html"><strong aria-hidden="true">4.</strong> Linux</a></li><li class="chapter-item expanded "><a href="../go.html"><strong aria-hidden="true">5.</strong> Go</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../go/Go.html"><strong aria-hidden="true">5.1.</strong> 基础</a></li><li class="chapter-item expanded "><a href="../go/Goroutine.html"><strong aria-hidden="true">5.2.</strong> 协程</a></li></ol></li><li class="chapter-item expanded "><a href="../frontend.html"><strong aria-hidden="true">6.</strong> 前端</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../frontend/HTML&CSS.html"><strong aria-hidden="true">6.1.</strong> HTML &amp; CSS</a></li><li class="chapter-item expanded "><a href="../frontend/Browser.html"><strong aria-hidden="true">6.2.</strong> 浏览器</a></li></ol></li><li class="chapter-item expanded "><a href="../android.html"><strong aria-hidden="true">7.</strong> 安卓</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../android/Activity.html"><strong aria-hidden="true">7.1.</strong> 活动</a></li><li class="chapter-item expanded "><a href="../android/System.html"><strong aria-hidden="true">7.2.</strong> 系统</a></li></ol></li><li class="chapter-item expanded "><a href="../others.html"><strong aria-hidden="true">8.</strong> 其他</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../others/Distributed.html"><strong aria-hidden="true">8.1.</strong> 分布式</a></li><li class="chapter-item expanded "><a href="../others/Server.html"><strong aria-hidden="true">8.2.</strong> 服务器</a></li><li class="chapter-item expanded "><a href="../others/Middleware.html"><strong aria-hidden="true">8.3.</strong> 中间件</a></li><li class="chapter-item expanded "><a href="../others/Docker.html"><strong aria-hidden="true">8.4.</strong> Docker</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="计算机网络"><a class="header" href="#计算机网络">计算机网络</a></h1>
<h2 id="osi--tcpip"><a class="header" href="#osi--tcpip">OSI &amp; TCP/IP</a></h2>
<ul>
<li>
<p>OSI的体系结构（七层）：</p>
<p>自上而下：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p>
<p>各层的作用：</p>
<ol>
<li>应用层：为用户的应用程序提供网络服务</li>
<li>表示层：将信息表示为一定形式和格式的数据流</li>
<li>会话层：负责通信主机之间的会话的建立、管理和拆除，协调通信双方的会话</li>
<li>传输层：负责通信主机间端到端的连接</li>
<li>网络层：负责将分组从源主机送到目的主机，包括寻址和最优路径选择等</li>
<li>数据链路层：提供可靠的帧传递，实现差错控制、流控等</li>
<li>物理层：提供透明的比特流传递</li>
</ol>
</li>
<li>
<p>TCP/IP的体系结构（四层）：</p>
<p>自上而下：应用层、传输层、网际层、网络接口层</p>
</li>
<li>
<p>TCP/IP的体系结构（五层）：</p>
<p>自上而下：应用层、传输层、网络层、数据链路层、物理层</p>
<p>各层的作用：</p>
<ol>
<li>应用层：通过应用进程间的交互来完成特定的网络应用。应用层协议定义的是应用进程间的通信和交互规则。对于不同的网络应用需要不同的应用层协议。</li>
<li>传输层：负责两台主机进程间的通信提供通用的数据传输服务，应用进程利用该服务传输应用层报文。</li>
<li>网络层：在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换节点，确保数据及时传送。</li>
<li>数据链路层：两台主机之间的数据传输，总是在一段一段的链路上传输的，这就需要专门的链路层协议。在两个相邻节点传送数据时，链路层将网络层交下来的IP数据报封装成帧，在两个相邻节点间的链路传送帧，每一帧包含数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</li>
<li>物理层：实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</li>
</ol>
</li>
</ul>
<h2 id="网络层"><a class="header" href="#网络层">网络层</a></h2>
<h3 id="ip地址"><a class="header" href="#ip地址">IP地址</a></h3>
<p>IP地址可定义为：{&lt;网络号&gt;，&lt;主机号&gt;}</p>
<p>IP地址分类：</p>
<table><thead><tr><th>类别</th><th>类别位</th><th>网络号字节长</th><th>主机号字节长</th><th>单播或多播</th></tr></thead><tbody>
<tr><td>A</td><td>0(1-126)</td><td>1</td><td>3</td><td>单播</td></tr>
<tr><td>B</td><td>10(128-191)</td><td>2</td><td>2</td><td>单播</td></tr>
<tr><td>C</td><td>110(192-223)</td><td>3</td><td>1</td><td>单播</td></tr>
<tr><td>D</td><td>1110(224-239)</td><td></td><td></td><td>多播</td></tr>
<tr><td>E</td><td>1111(240-255)</td><td></td><td></td><td></td></tr>
</tbody></table>
<p>IP地址指派范围：</p>
<table><thead><tr><th>网络类别</th><th>最大可指派的网络数</th><th>第一个可指派的网络号</th><th>最后一个可指派的网络号</th><th>每个网络中的最大主机数</th></tr></thead><tbody>
<tr><td>A</td><td>126 ($2^7 - 2$)</td><td>1</td><td>126</td><td>16777214</td></tr>
<tr><td>B</td><td>16383 ($2^{14} - 1$)</td><td>128.1</td><td>191.255</td><td>65534</td></tr>
<tr><td>C</td><td>2097151 ($2^{21} - 1$)</td><td>192.0.1</td><td>223.255.255</td><td>254</td></tr>
</tbody></table>
<h4 id="ipv6"><a class="header" href="#ipv6">IPv6</a></h4>
<p>IPv6总长度为128bit，通常分为8组，每组4位十六进制数的形式，每组十六进制数间用冒号分隔。为了书写方便，IPv6提供了压缩格式，每组中的前导0皆可省略，地址中包含的连续两个或多个均为0的组可用双冒号代替。</p>
<p>格式：</p>
<table><thead><tr><th>站点前缀</th><th>子网ID</th><th>接口ID</th></tr></thead><tbody>
<tr><td>前48位（前三字段）</td><td>第二字段（16位）</td><td>后64位（最后四字段）</td></tr>
</tbody></table>
<ul>
<li>站点前缀：通常由ISP或区域Internet注册机构分配的公共拓扑</li>
<li>子网ID：描述专用拓扑（站点拓扑），站点内部ID</li>
<li>站点ID：标记，可以从接口的MAC地址自动配置，亦可采用EUI-64格式手动配置</li>
</ul>
<p>前缀：表示网络地址空间。常用IPv6地址或前缀：</p>
<ul>
<li><code>::/128</code>：即0:0:0:0:0:0:0:0，只能作为尚未获得正式地址的主机的源地址，不能作为目的地址，不能分配给真实的网络接口</li>
<li><code>::1/128</code>：回环地址</li>
<li><code>ff00::/8</code>：组播地址</li>
<li><code>fe80::/10</code>：本地链路地址，用于单一链路，适用于自动配置、邻机发现等，路由器不转发</li>
<li><code>::A.B.C.D</code>：其中&lt;A, B, C, D&gt;代表IPv4地址，兼容IPv4的IPv6地址，自动将IPv6包以隧道方式在IPv4网络中传送的IPv4/IPv6节点将使用这些地址</li>
<li><code>::FFFF:A.B.C.D</code>：其中&lt;A, B, C, D&gt;代表IPv4地址，是IPv4地址映射过来的IPv6地址，是在不支持IPv6的网上用于表示IPv4节点</li>
</ul>
<h3 id="子网掩码"><a class="header" href="#子网掩码">子网掩码</a></h3>
<p><em><strong>TODO</strong></em></p>
<h2 id="udp"><a class="header" href="#udp">UDP</a></h2>
<p>用户数据报协议，是OSI参考模型中一种无连接传输层协议，提供面向事务的简单的不可靠信息传输服务。</p>
<p>特点：</p>
<ul>
<li>无连接，发送数据前不需建立连接，发送数据后亦不需释放连接</li>
<li>面向报文</li>
<li>尽最大努力交付</li>
<li>无拥塞控制</li>
<li>首部开销小，只有8个字节</li>
<li>支持一对一、一对多、多对多的交互通信</li>
</ul>
<p><em>注：UDP不存在拆包粘包现象，是因为UDP有消息保护边界。UDP对应用层交下来的报文既不合并也不拆分，而是保留这些报文的边界，一次交付一个完整的报文。</em></p>
<h3 id="首部格式"><a class="header" href="#首部格式">首部格式</a></h3>
<p>首部只有8个字节，由4个字段组成，每个字段2个字节。</p>
<table><thead><tr><th>字段</th><th>字段意义</th></tr></thead><tbody>
<tr><td>源端口</td><td>在需要对方回信时选用，不需要时可用全0</td></tr>
<tr><td>目的端口</td><td>这在终点交付报文时必须使用</td></tr>
<tr><td>长度</td><td>UDP用户数据报的长度，其最小值是8（仅有首部）</td></tr>
<tr><td>检验和</td><td>检测UDP用户数据报在传输中是否有错，有错就丢弃</td></tr>
</tbody></table>
<h2 id="tcp"><a class="header" href="#tcp">TCP</a></h2>
<p>特点：</p>
<ol>
<li>面向连接</li>
<li>提供全双工通信</li>
<li>只支持点对点（一对一）通信</li>
<li>提供可靠交付服务</li>
<li>面向字节流</li>
</ol>
<p>TCP如何保证可靠传输：</p>
<ol>
<li>数据包校验</li>
<li>对失序数据包重排序</li>
<li>丢弃重复数据</li>
<li>应答机制</li>
<li>超时重发</li>
<li>流量控制</li>
</ol>
<h3 id="arq"><a class="header" href="#arq">ARQ</a></h3>
<p><em><strong>TODO</strong></em></p>
<p>自动重传请求ARQ协议</p>
<p>连续ARQ协议</p>
<h3 id="流量控制"><a class="header" href="#流量控制">流量控制</a></h3>
<p>TCP利用滑动窗口来实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为0，则发送方不能发送数据。</p>
<blockquote>
<p><strong>滑动窗口</strong></p>
<p>一种流量控制技术，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为0时，发送方一般不能再发送数据报，但有两种情况除外，一种是可以发送紧急数据，另一种是发送方可以发送一个1字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</p>
</blockquote>
<h3 id="拥塞控制"><a class="header" href="#拥塞控制">拥塞控制</a></h3>
<blockquote>
<p>拥塞：在某段时间内，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。</p>
</blockquote>
<p>为了防止过多的数据注入到网络中，可以使网络中的路由器或链路不致于过载。为了进行拥塞控制，TCP发送方要维持一个拥塞窗口(cwnd)的状态变量，其大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接收窗口中较小的一个。</p>
<p><strong>检测拥塞的指标</strong></p>
<ul>
<li>平均队列长度</li>
<li>超时重传的分组数</li>
<li>平均分组时延</li>
<li>分组时延的标准差</li>
<li>由于缺少缓存空间而被丢弃的分组的百分数</li>
<li>……</li>
</ul>
<p>这些指标的上升标志着拥塞增加。</p>
<p><strong>拥塞控制算法</strong></p>
<ul>
<li>慢开始：当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，亦即由小到大逐渐增大拥塞窗口数值，cwnd初始值为1，每经过一个传播轮次，cwnd加倍；</li>
<li>拥塞避免：让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送方的cwnd加1；</li>
<li>快重传与快恢复（FRR）：FRR能快速恢复丢失的数据包，若无FRR而数据包丢失了，TCP将会使用定时器来要求传输暂停，在暂停的这段时间内，没有新的或复制的数据包被发送；有FRR，如果接收机接收到一个不按顺序的数据段，会立即给发送机发送一个重复确认，如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段，不会因为重传时要求的暂停被耽误；当有单独的数据包丢失时，FRR能有效地工作，而当有多个数据信息包在某段很短的时间内丢失时则不能很好地工作。</li>
</ul>
<p><em>注：</em></p>
<ul>
<li><em>流量控制与拥塞控制的区别：后者是一个全局性的过程，涉及到所有的主机和路由器，以及与降低传输性能有关的所有因素；而前者指点对点通信量的控制，是个端到端的问题，流量控制所要做到的是抑制发送端发送数据的速率，以便使接收端来得及接收；</em></li>
<li><em>在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理AQM），以减少网络拥塞的发生。</em></li>
</ul>
<h3 id="三次握手"><a class="header" href="#三次握手">三次握手</a></h3>
<p>刚开始客户端和服务端均处于CLOSED状态，客户端主动打开连接，服务端被动打开连接，此时服务端处于LISTEN状态。</p>
<p>第一次：客户端给服务端发一个SYN报文，并设置一个序列号。此时客户端进入SYN_SEND状态。</p>
<p>第二次：服务端收到客户端的SYN报文后，以自己的SYN报文作为应答，并指定一个序列号；同时将客户端的序列号+1作为ACK的值，表示自己已收到客户端的SYN报文，此时服务端处于SYN_RCVD状态。</p>
<p>第三次：客户端收到SYN报文后，会发送一个ACK报文，并将服务端报文的序列号+1作为自己的ACK的值，而自己的序列号为第二次握手时服务端ACK报文段的确认号，此时客户端处于ESTABLISHED状态。服务端在收到报文后也进入ESTABLISHED状态，双方建立连接。</p>
<p><strong>为什么客户端要再发一次确认？</strong></p>
<p>防止已失效的连接请求报文段突然又传到服务端导致发生错误。</p>
<p><em>已失效的连接请求报文段：<em><strong>TODO</strong></em></em></p>
<h3 id="四次挥手"><a class="header" href="#四次挥手">四次挥手</a></h3>
<p>刚开始双方均处于ESTABLISHED状态，客户端发起关闭请求，</p>
<p>第一次：客户端发送一个FIN报文，报文中指定一个序列号，此时客户端处于FIN_WAIT_1状态。</p>
<p>第二次：服务端收到FIN报文后，会发送ACK报文，确认号指定为客户端FIN报文的序列号+1，同时指定自己的序列号，此时服务端处于CLOSE_WAIT状态。客户端收到来自服务端的确认后进入FIN_WAIT_2状态。</p>
<p>第三次：服务端发出FIN报文，报文指定一个序列号，确认号与第二次挥手时发送给客户端的确认报文一样，此时服务端进入LACK_ACK状态。</p>
<p>第四次：客户端收到服务端的FIN报文后，会发送ACK报文，确认号为服务端FIN报文的序列号+1，自己的序列号指定为第一次挥手时发送给服务端的FIN报文的序列号+1，然后进入TIME_WAIT状态。此时连接仍未释放，须经过时间等待计时器设置的时间2MSL后才进入CLOSED状态。</p>
<p><strong>为什么要等待2MSL？</strong></p>
<ol>
<li>为了保证客户端发送的最后一个ACK报文段到达服务端，此报文段有可能丢失导致处于LAST_ACK状态的服务器收不到确认，服务器此时会超时重传FIN+ACK报文段，而客户机就能在2MSL时间内收到该重传的报文段，接着客户机再重新发送确认，重新启动2MSL计时器；</li>
<li>防止已失效的连接请求报文段出现在本连接中，客户机再发送完最后一个确认后，再经过2MSL时间便可以使本连接持续的时间内所产生的所有报文段都从网络中消失。</li>
</ol>
<p><strong>为什么要四次？</strong></p>
<p><em><strong>TODO</strong></em></p>
<h3 id="保活计时器"><a class="header" href="#保活计时器">保活计时器</a></h3>
<p>客户已主动与服务器建立了TCP连接，但后来客户端的主机突然出现故障，服务器以后便不能再收到来自客户发来的数据，为使服务器不再等待，遂使用保活计时器。服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是2小时，若2小时没有收到客户的数据，服务器就发送一个探测报文段，以后每隔75秒发送一次，若一连发送10个探测报文段后仍无客户的响应，服务器就认为客户机出现故障，接着就关闭该连接。</p>
<h3 id="拆包与粘包"><a class="header" href="#拆包与粘包">拆包与粘包</a></h3>
<p><em>注：TCP是面向字节流的协议，没有“包”的概念，说“拆包”和“粘包”是为了有助于形象地理解这两种现象。</em></p>
<ul>
<li>拆包：如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP会将其拆分为多次发送</li>
<li>粘包：如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP会将多个请求合并为同一个进行发送</li>
</ul>
<p><strong>解决方法</strong></p>
<ul>
<li>发送端将每个包都封装成固定的长度</li>
<li>发送端在每个包末尾使用固定的分隔符，如<code>\r\n</code>，若发生拆包则需要等待多个包发送过来之后找到其中的<code>\r\n</code>进行合并</li>
<li>将消息分为消息头和消息体，头部保存整个消息的长度，只有读取到足够长度的消息才能算是读到了完整的消息</li>
<li>通过自定义协议进行处理</li>
</ul>
<h3 id="短连接与长连接"><a class="header" href="#短连接与长连接">短连接与长连接</a></h3>
<p>TCP在进行读写之前，server与client必须提前建立一个连接，建立连接的过程便是三次握手，释放/关闭连接需要四次挥手，这个过程比较消耗网络资源且有时间延迟。</p>
<ul>
<li>
<p>短连接：Server与Client建立连接后，读写完成后就关闭连接，下次再要互相发送消息需要重新连接</p>
<p>短连接实现和管理都比较简单，但每一次读写都建立连接必然会带来大量网络资源的消耗，且建立连接也耗费时间。</p>
</li>
<li>
<p>长连接：Server与Client建立连接后，即使Client与Server完成一次读写，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接</p>
<p>长连接可以省去较多的TCP建立和关闭的操作，降低对网络资源的依赖，节约时间，对于频繁请求资源的用户来说非常适用长连接。</p>
</li>
</ul>
<h3 id="心跳机制"><a class="header" href="#心跳机制">心跳机制</a></h3>
<p>在TCP保持长连接的过程中，可能会出现断网等网络异常情况，异常发生的时候，client和server之间若无交互，双方将无法发现对方已经掉线。为了解决这个问题引入了心跳机制。</p>
<p>Client和Server之间在一定时间内无数据交互时，即处于idle状态时，客户端或服务器就会发送一个特殊的数据包给对方，当接收方收到这个数据报文后，也立即发送一个特殊的数据报文回应发送方，此即一个PING-PONG交互。所以当某一端收到心跳消息后，就知道对方仍然在线，这就确保了TCP连接的有效性。</p>
<p>TCP实际自带长连接选项，本身亦有心跳包机制，也即TCP选项SO_KEEPALIVE。不过TCP层面的长连接灵活性不够，所以一般情况下都是在应用层协议上实现自定义心跳机制。</p>
<h2 id="http"><a class="header" href="#http">HTTP</a></h2>
<p>超文本传输协议（Hypertext Transfer Protocol），通过浏览器和服务器进行数据交互，进行超文本（文本、图片、视频等）传输的规定，即协议规定了超文本传输所要遵守的规则。</p>
<p>特点：</p>
<ul>
<li>基于TCP协议</li>
<li>无状态</li>
<li>多次请求</li>
</ul>
<p>HTTP请求类型：</p>
<ul>
<li>GET：请求从服务器获取特定资源</li>
<li>POST：在服务器上创建一个新的资源</li>
<li>PUT：更新服务器上的资源（客户端提供更新后的整个资源）</li>
<li>DELETE：从服务器删除特定的资源</li>
<li>HEAD：获取报文首部，和GET类似但不返回报文实体主体部分</li>
<li>OPTIONS：查询指定URL支持的方法</li>
<li>PATCH：对资源进行部分修改，PUT亦可用于修改资源，但只能完全替代原始资源</li>
<li>TRACE：追踪路径，服务器会将通信路径返回给客户端</li>
<li>CONNECT：要求在与代理服务器通信时建立隧道</li>
</ul>
<h3 id="报文结构"><a class="header" href="#报文结构">报文结构</a></h3>
<ul>
<li>
<p>请求报文</p>
<pre><code>方法 URL 版本 [开始行/请求行]
首部字段名: 值 [首部行]
...
首部字段名: 值

实体主体（通常不用）
</code></pre>
</li>
<li>
<p>响应报文</p>
<pre><code>版本 状态码 短语 [开始行/请求行]
首部字段名: 值 [首部行]
...
首部字段名: 值

实体主体（有些响应报文不用）
</code></pre>
</li>
</ul>
<h3 id="状态码"><a class="header" href="#状态码">状态码</a></h3>
<table><thead><tr><th>状态码</th><th>类别</th><th>原因短语</th></tr></thead><tbody>
<tr><td>1XX</td><td>Informational（信息性）</td><td>接收的请求正在处理</td></tr>
<tr><td>2XX</td><td>Success（成功）</td><td>请求正常处理完毕</td></tr>
<tr><td>3XX</td><td>Redirection（重定向）</td><td>需要进行附加操作以完成请求</td></tr>
<tr><td>4XX</td><td>Client Error（客户端错误）</td><td>服务器无法处理请求</td></tr>
<tr><td>5XX</td><td>Server Error（服务端错误）</td><td>服务器处理请求出错</td></tr>
</tbody></table>
<h3 id="http10--http11--http20"><a class="header" href="#http10--http11--http20">HTTP/1.0 &amp; HTTP/1.1 &amp; HTTP/2.0</a></h3>
<p>HTTP/1.0和HTTP/1.1的区别：</p>
<ol>
<li>长连接</li>
<li>错误状态响应码</li>
<li>缓存处理</li>
<li>带宽优化及网络连接的使用</li>
</ol>
<p>HTTP/2.0：采用多路复用，把HTTP报文分割成更小的二进制帧来传送，不同的HTTP请求报文可以混合在一个TCP连接上传输，服务器收到后，在根据二进制帧里面存放的ID来进行分类、拼接。采用这种方式，相当于服务器可以同时处理几个不同的HTTP请求，亦即不需要把整个HTTP请求处理完，就可以去处理其他的HTTP请求了，并且HTTP还对请求头部进行了压缩。</p>
<h3 id="http长连接和短连接"><a class="header" href="#http长连接和短连接">HTTP长连接和短连接</a></h3>
<p>HTTP/1.0默认使用短连接。</p>
<p>HTTP/1.1默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加上这行代码：</p>
<pre><code class="language-http">Connection:keep-alive
</code></pre>
<p>HTTP的短连接和长连接，实质上是TCP的长连接和短连接。</p>
<h3 id="https"><a class="header" href="#https">HTTPS</a></h3>
<p>HTTPS是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议。</p>
<h4 id="工作过程"><a class="header" href="#工作过程">工作过程</a></h4>
<ol>
<li>客户端发送自己支持的加密规则给服务器；</li>
<li>服务器从中选出一套加密算法和hash算法以及自己的身份信息以证书的形式发送给浏览器，证书中包含服务器信息，加密公钥，证书机构；</li>
<li>客户端将验证证书的合法性，如果验证通过证书，浏览器会生成一串随机数，并用证书中的公钥加密；之后用约定好的hash算法计算握手信息，然后用生成的密钥进行加密，一起发送给服务器；</li>
<li>服务器接收到客户端传来的信息，用私钥解析出密码，用密码解析握手消息，验证hash值是否和浏览器发来的一致；</li>
<li>如果计算hash值一致则握手成功，使用密钥加密消息。</li>
</ol>
<h4 id="与http的区别"><a class="header" href="#与http的区别">与HTTP的区别</a></h4>
<ol>
<li>开销：HTTPS协议需要到CA申请证书，一般免费证书少，需要交费；</li>
<li>资源消耗：HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的SSL加密传输协议，需要消耗更多的CPU和内存资源；</li>
<li>端口不同：HTTP的端口是80，HTTPS的端口是443；</li>
<li>安全性：HTTP连接简单，无状态；HTTPS是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，较HTTP安全。</li>
</ol>
<h4 id="优缺点"><a class="header" href="#优缺点">优缺点</a></h4>
<p>优点：</p>
<ol>
<li>可认证用户和服务器，确保数据发送到正确的客户机和服务器</li>
<li>比较安全，可防止数据在传输过程中不被窃取、改变，确保数据完整性</li>
<li>大幅增加了中间人攻击的成本</li>
</ol>
<p>缺点：</p>
<ol>
<li>握手阶段费时</li>
<li>SSL证书需要交费，功能越强的证书费用越高</li>
<li>SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名</li>
<li>缓存不如HTTP高效，会增加数据的开销和功耗，甚至已有的安全措施会因此受到影响</li>
<li>加密范围比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到作用</li>
<li>SSL证书的信用链体系不完全</li>
</ol>
<h3 id="websocket"><a class="header" href="#websocket">WebSocket</a></h3>
<p><em><strong>TODO</strong></em></p>
<h3 id="sessioncookietoken"><a class="header" href="#sessioncookietoken">Session/Cookie/Token</a></h3>
<p>Session和Cookie：</p>
<p>由于HTTP的无状态性，为了使某个域名下的所有网页能够共享某些数据，出现了session和cookie，客户端访问服务器的流程如下：</p>
<ol>
<li>客户端发送一个HTTP请求到服务端；</li>
<li>服务端接收到请求后，建立一个session，并发送一个HTTP响应到客户端，响应头包括Set-Cookie头部，该头部包含了sessionId；</li>
<li>在客户端发起的第二次请求，加入服务端给了Set-Cookie，浏览器会自动在请求头中添加cookie；</li>
<li>服务端接收请求，分解cookie，验证信息，核对成功后返回响应给客户端。</li>
</ol>
<p><strong>Cookie失效怎么传数据</strong></p>
<p><em><strong>TODO</strong></em></p>
<p><em>注意：<strong>TODO</strong></em></p>
<p>Token（令牌）认证方式类似于临时的证书签名，并且是一种服务端无状态的认证方式，非常适合于Restful API的场景，所谓无状态即是服务端不会保存身份认证相关的数据。</p>
<p>Token组成：</p>
<ul>
<li>uid，用户唯一身份标识</li>
<li>time，当前时间的时间戳</li>
<li>sign，签名，使用hash/encrypt压缩成定长的十六进制字符串，以防止第三方恶意拼接</li>
<li>固定参数（可选），将一些常用的固定参数加入到token中是为了避免重复查库</li>
</ul>
<p>Token存放：在客户端一般存放于<code>localStorage</code>，<code>cookie</code>，<code>sessionStorage</code>中；在服务器一般存放于数据库中。</p>
<p>Token认证流程：</p>
<ol>
<li>用户登录，成功后服务器返回token给客户端；</li>
<li>客户端受到数据后保存在客户端；</li>
<li>客户端再次访问服务器，将token放入headers中；</li>
<li>服务器端采用过滤器校验，校验成功则返回请求数据，校验失败则返回错误码。</li>
</ol>
<p><em>注：Token可以抵抗CSRF攻击，攻击者无法访问用户的token，浏览器不会自动添加到headers里，提交的表单无法通过服务器过滤，无法形成攻击。</em></p>
<h2 id="dns"><a class="header" href="#dns">DNS</a></h2>
<p>域名解析协议。解析过程：</p>
<ul>
<li>
<p>主机向本地域名服务器的查询一般采用递归查询</p>
<p>如果主机所询问的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向根域名服务器继续发出查询请求报文（即替主机继续查询），而不是让主机自己进行下一步查询，因此递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。</p>
</li>
<li>
<p>本地域名服务器向根域名服务器的查询采用迭代查询</p>
<p>当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器下一步应向哪个域名服务器进行查询，然后让本地域名服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询，顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地域名服务器下一步应当向哪一个权限域名服务器进行查询。最后本地域名服务器得到了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机。</p>
</li>
</ul>
<h3 id="域名缓存"><a class="header" href="#域名缓存">域名缓存</a></h3>
<p>为了提高DNS的查询效率，并减轻服务器的负荷和减少Internet上的DNS查询报文数量，在域名服务器中广泛使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。</p>
<h2 id="浏览器输入url到显示页面的过程"><a class="header" href="#浏览器输入url到显示页面的过程">浏览器输入URL到显示页面的过程</a></h2>
<ol>
<li>
<p>浏览器查找域名对应的IP地址</p>
<p>浏览器查询DNS，获取域名对应的IP地址。具体过程包括浏览器搜索自身的DNS缓存、操作系统的DNS缓存、读取本地的hosts文件和向本地DNS服务器进行查询等。</p>
</li>
<li>
<p>浏览器向WEB服务器发送一个HTTP请求</p>
<p>浏览器获得域名对应的IP地址后，向服务器请求建立连接，发起三次握手。TCP连接建立后，浏览器向服务器发送HTTP请求。</p>
</li>
<li>
<p>服务器处理请求，返回一个HTTP响应</p>
<p>服务器收到请求，根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器。</p>
</li>
<li>
<p>浏览器解析并渲染页面</p>
<p>浏览器解析并渲染视图，若遇到对JS、CSS文件及图片等静态资源的引用，则重复上述步骤并向服务器请求资源；浏览器根据请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</p>
</li>
</ol>
<h2 id="网络攻击"><a class="header" href="#网络攻击">网络攻击</a></h2>
<ol>
<li>
<p>CSRF/XSRF：跨站域请求伪造，<em><strong>TODO</strong></em></p>
</li>
<li>
<p>XSS（Cross Site Scripting）：跨站脚本攻击，利用网站漏洞从用户恶意盗取信息（静态站点不会受其影响）</p>
<p>恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的特点，进而添加一些脚本代码嵌入到web页面中去，使别的用户访问时都会执行相应的嵌入代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的方式。</p>
<p>分类：</p>
<ul>
<li>反射性XSS攻击（非持久性XSS攻击）</li>
<li>持久性XSS攻击</li>
</ul>
<p>危害：</p>
<ul>
<li>盗取各类用户账号，如机器登录账号、用户网银账号、各类管理员账号</li>
<li>控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力</li>
<li>盗窃企业重要的具有商业价值的资料</li>
<li>非法转账</li>
<li>强制发送电子邮件</li>
<li>网站挂马</li>
<li>控制受害者机器向其他网站发起攻击</li>
</ul>
<p>主要原因：过于信任客户端提交的数据。</p>
<p>解决办法：不信任任何客户端提交的数据，只要是客户端提交的数据就应该先进行相应的过滤处理然后方可进行下一步操作。</p>
<p>修复方针：</p>
<ul>
<li>将重要的Cookie标记为HTTP Only，JS中的<code>document.cookie</code>语句将不能获取到Cookie</li>
<li>表单数据规定值的类型</li>
<li>对数据进行HTML Encode处理</li>
<li>过滤或移除特殊的HTML标签、JS事件标签</li>
</ul>
</li>
<li>
<p>SQL注入：在用户输入的字符串中加入SQL语句，如果在设计不良的程序中忽略了检查，这些注入进去的SQL语句会被服务器数据库误认为是正常的SQL语句而执行，攻击者可利用执行计划以外的命令或访问未被授权的数据</p>
<p>原理：</p>
<ul>
<li>恶意拼接查询</li>
<li>利用注释执行非法命令</li>
<li>传入非法参数</li>
<li>添加额外条件</li>
</ul>
<p>攻击思路：</p>
<ol>
<li>寻找SQL注入位置</li>
<li>判断服务器类型与后台数据库类型</li>
<li>针对不同的服务器和数据库特点进行SQL注入攻击</li>
</ol>
<p>案例：</p>
<pre><code class="language-java">String sql = &quot;select * from user_table where username = '&quot; + username + &quot;' and password = '&quot; + password + &quot;'&quot;;
// 当输入了上面的用户名和密码，上面语句变成：
// select * from user_table where username = '' or 1=1 -- and password = ''
// 分析以上语句，条件后面or 1 = 1意味着这个条件一定为真，然后后面的`--`注释掉了密码（利用注释执行非法命令；添加额外条件）
// 以上语句还可改写为：
// select * from user_table where username = '';drop table [db table] -- ' and password = '' （恶意拼接查询）
</code></pre>
<p>规避方法：</p>
<ul>
<li>
<p>过滤输入内容，校验字符串</p>
</li>
<li>
<p>参数化查询，绑定变量，使用预编译语句</p>
<p>在SQL语句中变量使用<code>?</code>表示，使用预编译的SQL语句语义不会发生改变，黑客无法改变SQL语句的结构。</p>
</li>
<li>
<p>检查变量数据类型和格式</p>
</li>
</ul>
</li>
<li>
<p>DDoS攻击</p>
<p><em><strong>TODO</strong></em></p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../basis/OS.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../basis/Project.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../basis/OS.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../basis/Project.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
