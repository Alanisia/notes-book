# 数据库

## 范式

- 第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项；
- 第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性；
- 第三范式：任何非主属性不依赖于其他非主属性。

## SQL

一条SQL语句在数据库框架中的执行流程：

## MySQL

### 存储引擎

- MyISAM

    不支持事务，支持全文索引，不支持外键，只支持表锁，不支持MVCC。

    使用`count()`会直接存储总行数，即对于`select count(*) from table;`如果数据量大会瞬间返回。

- InnoDB

    支持事务，支持全文索引（InnoDB 5.6之后），支持外键，支持表锁和行锁，支持MVCC。

    使用`count()`不会直接存储总行数，即对于`select count(*) from table;`需要一行行扫描。

### 索引

#### 索引分类

- 从数据结构角度

  1. 树索引
  2. Hash索引

- 从物理存储角度

  1. 聚集索引(clustered index)
  2. 非聚集索引(non-clustered index)

- 从逻辑角度

  1. 普通索引
  2. 唯一索引
  3. 主键索引
  4. 联合索引
  5. 全文索引

#### 索引底层

- 哈希表

- B树

- B+树

#### 聚簇索引

聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。特点是存储数据的顺序和索引顺序一致。一般情况下主键会默认创建聚簇索引，且一张表只允许存在一个聚簇索引。

聚簇索引与非聚簇索引的区别：

聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍是索引节点，只不过有指向对应数据块的指针。

#### 哈希索引

哈希索引能以O(1)时间复杂度进行查找，但失去了有序性，无法用于排序与分组，只支持精确查找，无法用于部分查找和范围查找。

InnoDB存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用得非常频繁时，会在B+树索引之上再创建一个哈希索引，这样让B+树索引具有哈希索引的一些优点，比如：快速的哈希查找。

#### 覆盖索引

如果一个索引包含了满足查询语句中字段与条件的数据就叫覆盖索引，覆盖所有具有以下优点：

1. 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量；
2. 一些存储引擎（如MyISAM）的内存中只缓存索引，而数据依赖于操作系统来缓存，因此只访问索引可以不使用系统调用（通常比较费时）；
3. 对于InnoDB引擎，若辅助索引能够覆盖查询，则无需访问主索引。

#### 索引失效

1. 索引列参与表达式计算：

    ```sql
    select `sname` from `stu` where `age` + 10 = 30;
    ```

2. 函数运算：

    ```sql
    select `sname` from `stu` where left(`date`, 4) < 1990;
    ```

3. 模糊查询：

    ```sql
    select * from `manong` where `uname` like '%码农%'; -- 走索引（？）
    select * from `manong` where `uname` like "%码农%"; -- 不走索引（？）
    ```

4. 字符串与数字比较：

    ```sql
    create table `a`(`a` char(10));
    explain select * from `a` where `a` = "1"; -- 走索引
    explain select * from `a` where `a` = 1; -- 不走索引
    ```

5. 查询条件有OR，即使其中有条件带索引：

    ```sql
    select * from `dept` where `dname` = 'xxx' or `loc` = 'xx' or `deptno` = 45;
    ```

    换言之，就是要求使用的所有字段，都须建立索引；

6. MySQL内部优化器会对SQL语句进行优化，如果优化器估计使用全表扫描要比使用索引快则不走索引；

7. 正则表达式不走索引。

### 查询优化

- 减少请求的数据量

  - 只返回必要的行
  - 只返回必要的列
  - 缓存重复查询的数据

- 减少服务器端扫描的行数：最有效的方式是使用索引来覆盖查询。

### 事务

逻辑上的一种操作，要么执行，要么不执行。

四大特性（ACID）：

- 原子性（Atomicity）：事务是最小执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用。
- 一致性（Consistency）：执行数据前后，数据保持一致，多个事务对同一数据读取的结果是相同的。
- 隔离性（Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。
- 持久性（Durability）：一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

#### 并发事务带来的问题

- 脏读（Dirty Read）：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另一个事务也访问了这个数据，然后使用了这个数据。由于这个数据是还没有提交的数据，那么另一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
- 丢失修改（Lost to Modify）：指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失。
- 不可重复读（Unrepeatable Read）：指在一个事务内多次读同一数据，在这个事务还没有结束时，另一事务也访问该数据，那么在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据不一样，这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
- 幻读（Phantom Read）：与不可重复读类似，它发生在一个事务读取了几行数据，另一个并发事务插入了一些数据时，在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生幻觉一样，因此称为幻读。

#### 事务隔离级别

1. 读取未提交（READ-UNCOMMITTED）

2. 读取已提交（READ-COMMITTED）

3. 可重复读（REPEATABLE-READ）

4. 串行化（SERIALIZABLE）

### 锁机制

- 表级锁：锁定粒度最大的一种锁，对当前操作的整张表加锁。实现简单，资源消耗比较少，加锁快，不会出现死锁。其锁定粒度大，触发锁冲突概率最高，并发度最低。MyISAM和InnoDB引擎都支持表级锁。

- 行级锁：锁定粒度最小的一种锁，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突，其加锁粒度小，并发度高，但加锁的开销也大，加锁慢，会出现死锁。

InnoDB存储引擎的锁算法有三种：

1. Record Lock：单个行记录上的锁
2. Gap Lock：间隙锁，锁定一个范围，不包括记录本身
3. Next-key Lock：锁定一个范围，包括记录本身

### 主从复制

### 主从同步

### MVCC

## NoSQL