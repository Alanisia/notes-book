# 数据库

## 范式

- 第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项；
- 第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性；
- 第三范式：任何非主属性不依赖于其他非主属性。

## MySQL

### SQL

一条SQL语句在数据库框架中的执行流程：

1. 应用程序把查询SQL语句发送给服务器端执行；
2. 查询缓存，如果查询缓存是打开的，服务器接收到查询请求后，并不会直接去数据库查询，而是在数据库的查询缓存中找是否有相应的查询数据，如果存在，则直接返回给客户端；只有缓存不存在时，才会进行下面的操作；
3. 查询优化处理，生成执行计划，这个阶段主要包括解析SQL、预处理、优化SQL执行计划；
4. MySQL根据相应的执行计划完成整个查询；
5. 将查询结果返回给客户端。

### 存储引擎

- MyISAM

    不支持事务，支持全文索引，不支持外键，只支持表锁，不支持MVCC。

    使用`count()`会直接存储总行数，即对于`select count(*) from table;`如果数据量大会瞬间返回。

- InnoDB

    支持事务，支持全文索引（InnoDB 5.6之后），支持外键，支持表锁和行锁，支持MVCC。

    使用`count()`不会直接存储总行数，即对于`select count(*) from table;`需要一行行扫描。

### 索引

#### 索引分类

- 从数据结构角度

  1. 树索引
  2. [Hash索引](#哈希索引)

- 从物理存储角度

  1. 聚集索引(clustered index)
  2. 非聚集索引(non-clustered index)

- 从逻辑角度

  1. 普通索引
  2. 唯一索引
  3. 主键索引
  4. [联合索引](#联合索引)
  5. 全文索引

#### 索引底层

- 哈希表

- B树

- B+树

InnoDB使用B+树作为索引结构，

#### 联合索引

创建联合索引：

```sql
create index indexName on tableName(col1, col2, ..., colN);
```

联合索引可以建立多列（列数>=2，建议不超过3）。

好处：

1. 避免回表

2. 两列单独查返回行多而同时查返回行少的场景，联合索引更高效

#### 聚簇索引&非聚簇索引

**聚簇索引**

按照每张表的主键构建一颗B+树，同时叶子节点存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分，每张表只能有一个聚簇索引。

InnoDB通过主键聚集数据，若未定义主键，InnoDB会选择非空的唯一索引代替。若无这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。

聚簇索引优缺点：

- 优点

  1. 数据访问更快，因为聚簇索引将数据和索引保存在同一B+树中
  2. 对于主键的排序查找和范围查找速度非常快

- 缺点

  1. 插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则会出现页分裂，严重影响性能，对于InnoDB表，一般会定义一个自增的ID列作为主键
  2. 更新主键的代价很高，因为将会导致被更新的行移动，对于InnoDB表，一般定义为主键不可更新
  3. 二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据

**非聚簇索引（辅助索引）**

在聚簇索引之上创建的索引称为辅助索引，辅助索引访问数据总是二次查找。辅助索引叶子节点存储的不再是行的物理位置，而是主键值，通过辅助索引首先是找到主键值，再通过主键值找到数据行的数据页，再通过数据页中的Page Directory找到数据行。

InnoDB辅助索引的叶子节点并不包含行记录的全部数据，叶子节点除了包含键值外，还包含了相应的行数据的聚簇索引键。辅助索引的存在不影响数据在聚簇索引中的组织，所以一张表能有多个辅助索引。

#### 哈希索引

哈希索引能以O(1)时间复杂度进行查找，但失去了有序性，无法用于排序与分组，只支持精确查找，无法用于部分查找和范围查找。

InnoDB存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用得非常频繁时，会在B+树索引之上再创建一个哈希索引，这样让B+树索引具有哈希索引的一些优点，比如：快速的哈希查找。

#### 覆盖索引

如果一个索引包含了满足查询语句中字段与条件的数据就叫覆盖索引，覆盖所有具有以下优点：

1. 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量；
2. 一些存储引擎（如MyISAM）的内存中只缓存索引，而数据依赖于操作系统来缓存，因此只访问索引可以不使用系统调用（通常比较费时）；
3. 对于InnoDB引擎，若辅助索引能够覆盖查询，则无需访问主索引。

#### 索引失效

1. 索引列参与表达式计算：

    ```sql
    select `sname` from `stu` where `age` + 10 = 30;
    ```

2. 函数运算：

    ```sql
    select `sname` from `stu` where left(`date`, 4) < 1990;
    ```

3. 模糊查询：

    ```sql
    select * from `manong` where `uname` like '%码农%'; -- 走索引（？）
    select * from `manong` where `uname` like "%码农%"; -- 不走索引（？）
    ```

4. 字符串与数字比较：

    ```sql
    create table `a`(`a` char(10));
    explain select * from `a` where `a` = "1"; -- 走索引
    explain select * from `a` where `a` = 1; -- 不走索引
    ```

5. 查询条件有OR，即使其中有条件带索引：

    ```sql
    select * from `dept` where `dname` = 'xxx' or `loc` = 'xx' or `deptno` = 45;
    ```

    换言之，就是要求使用的所有字段，都须建立索引；

6. MySQL内部优化器会对SQL语句进行优化，如果优化器估计使用全表扫描要比使用索引快则不走索引；

7. 正则表达式不走索引。

#### 建立索引的原则

1. 选择唯一性索引

    唯一性索引的值是唯一的，可以更快地通过该索引来确定某条记录。

2. 为经常需要排序、分组和联合操作的字段建立索引

    经常需要`order by`、`group by`、`distinct`、`union`等操作的字段，排序操作会浪费很多时间，若为其建立索引可以有效避免排序操作。

3. 为常作为查询条件的字段建立索引

    若常使用某个字段来作为查询条件，那么该字段的查询速度会影响整个表的查询速度，为这样的字段建立索引可以提高整个表的查询速度。

4. 限制索引的数目

    索引不是越多越好，每个索引都会占用磁盘空间，索引越多需要的磁盘空间越大，修改表时对索引的重构和更新很麻烦，越多的索引会使表更新浪费时间。

5. 尽量使用数据量少的索引

    如果索引值很长，那么查询速度会受到影响。

6. 尽量使用前缀来索引

    若索引字段的值很长，最好使用值的前缀来索引，只检索字段前面的若干个字符可以提高检索速度。

7. 删除不再使用或者很少使用的索引

    表中的数据被大量更新，或数据的使用方式被改变后，原有的一些索引可能不再需要，这些索引应将它们删除，从而减少索引对更新操作的影响。

8. 最左前缀匹配原则
9. `=`和`in`可以乱序
10. 尽量选择区分度高的列作为索引

    > 区分度公式为`count(distinct col)/count(*)`，表示字段不重复的比例，比例越大扫描记录数越少，唯一键区分度是1。

11. 索引列不能参与计算
12. 尽量扩展索引而不是新建

### 查询优化

- 减少请求的数据量

  - 只返回必要的行
  - 只返回必要的列
  - 缓存重复查询的数据

- 减少服务器端扫描的行数：最有效的方式是使用索引来覆盖查询。

### 事务

逻辑上的一种操作，要么执行，要么不执行。

四大特性（ACID）：

- 原子性（Atomicity）：事务是最小执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用。
- 一致性（Consistency）：执行数据前后，数据保持一致，多个事务对同一数据读取的结果是相同的。
- 隔离性（Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。
- 持久性（Durability）：一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

#### 并发事务带来的问题

- 脏读（Dirty Read）：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另一个事务也访问了这个数据，然后使用了这个数据。由于这个数据是还没有提交的数据，那么另一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
- 丢失修改（Lost to Modify）：指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失。
- 不可重复读（Unrepeatable Read）：指在一个事务内多次读同一数据，在这个事务还没有结束时，另一事务也访问该数据，那么在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据不一样，这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
- 幻读（Phantom Read）：与不可重复读类似，它发生在一个事务读取了几行数据，另一个并发事务插入了一些数据时，在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生幻觉一样，因此称为幻读。

#### 事务隔离级别

1. 读取未提交（READ-UNCOMMITTED）

2. 读取已提交（READ-COMMITTED）

3. 可重复读（REPEATABLE-READ）

4. 串行化（SERIALIZABLE）

#### 事务日志

InnoDB事务日志包含redo log和undo log。Redo log是重做日志，提供前滚操作；Undo log是回滚日志，提供回滚操作。

Redo log通常是物理日志，记录的是数据页的物理修改，

### 锁机制

- 表级锁：锁定粒度最大的一种锁，对当前操作的整张表加锁。实现简单，资源消耗比较少，加锁快，不会出现死锁。其锁定粒度大，触发锁冲突概率最高，并发度最低。MyISAM和InnoDB引擎都支持表级锁。

- 行级锁：锁定粒度最小的一种锁，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突，其加锁粒度小，并发度高，但加锁的开销也大，加锁慢，会出现死锁。

InnoDB存储引擎的锁算法有三种：

1. Record Lock：单个行记录上的锁
2. Gap Lock：间隙锁，锁定一个范围，不包括记录本身
3. Next-key Lock：锁定一个范围，包括记录本身

### MVCC

多版本并发控制（Multi-Version Concurrency Control），现代数据库引擎实现中常用的处理读写冲突手段，目的在于提高数据库高并发场景下的吞吐性能。如此一来不同的事务在并发过程中，SELECT操作可以不加锁而是通过MVCC机制读取指定的版本历史记录，并通过一些手段保证读取的记录值符合事务所处的隔离级别，从而解决并发场景下的读写冲突。

InnoDB中MVCC的实现方式：每一行记录都有两个隐藏列：`DATA_TRX_ID`，`DATA_ROLL_PTR`（若无主键还会多一个主键列`DB_ROW_ID`）

### 主从复制

***TODO***

### 主从同步

***TODO***

## NoSQL

***TODO***