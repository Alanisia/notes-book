# 操作系统

## 进程&线程&协程

- 进程：并发执行程序时资源分配和管理的基本单位，进程中包括可执行代码、打开的文件描述符、挂起的信号、进程的状态、内存地址空间、存放全局变量的数据段，以及一个或多个执行线程等
- 线程：进程中活动的对象，或者说独立调度的基本单位，每个线程都拥有一个独立的程序计数器、线程堆栈和寄存器
- 协程：一种比线程更加轻量级的存在，一个线程也可拥有多个协程；避免了无意义的调度，由此可以提高性能，但程序员必须自己承担调度的责任，同时协程失去了标准使用多CPU的能力

进程与线程的区别：

1. 线程共享本进程的地址空间，而进程之间是独立的地址空间；
2. 线程共享本进程的资源和内存，IO，CPU等，不利于资源的管理和保护，而进程之间是独立的，能很好地进行资源的管理和保护；
3. 多进程比多线程健壮，一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉；
4. 每个独立的进程有一个程序的入口和顺序执行队列，执行开销大；线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程进行控制，执行开销小；
5. 两者均可并发执行；
6. 进程切换时，消耗的资源大，效率低，所以涉及到频繁的切换时，使用线程要好于进程，同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程；
7. 线程是处理器调度的基本单位，进程不是。

线程和协程的区别：

- 线程相对独立，有自己的上下文，切换由系统控制
- 协程相对独立，有自己的上下文，切换由自己控制，当前协程切换到其他协程由当前协程控制

## 上下文切换

当前任务在执行完CPU时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载就是一次上下文切换。

上下文切换通常是计算密集型的，上下文切换对系统来说意味着消耗大量的CPU时间。

## 进程间通信的方式

1. 匿名管道：***TODO***
2. 有名管道：***TODO***
3. 共享内存：***TODO***
4. 信号量：***TODO***
5. 消息队列：***TODO***
6. 信号：***TODO***

## 进程调度算法

1. 先来先服务调度算法
2. 短作业优先调度算法
3. 时间片轮转调度算法
4. 多级反馈队列调度算法
5. 最短剩余时间优先调度算法
6. 高响应比优先调度算法
7. 优先级调度算法

## 死锁

指的是多个进程或线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能被正常终止。

### 产生条件

1. 互斥：进程或线程要求对所分配的资源进行排他性控制，即在一段时间内某资源仅为一进程所占用
2. 环路等待：在发生死锁时，必然存在一个进程-资源的环形链
3. 请求与保持：当进程因请求资源而阻塞时，对已获得的资源保持不放
4. 不剥夺：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放

### 解决方法

1. 预防死锁
    1. 破坏请求条件：一次性分配所有资源，这样就不会再有请求了
    2. 破坏保持条件：只要有一个资源得不到分配，也不给这个进程分配其他资源
    3. 破坏不可剥夺条件：当某进程获得了部分资源，但得不到其他资源，则释放已占有的资源
    4. 破坏环路等待条件：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反
2. 避免死锁
3. 检测死锁
    1. 银行家算法
4. 解除死锁
    1. 资源剥夺：挂起某些死锁进程，并抢占其资源，将这些资源分配给其他死锁进程（但应该防止被挂起的进程长时间得不到资源）
    2. 撤销进程：强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源（撤销的原则可以按进程优先级和撤销进程代价的高低进行）
    3. 进程回退：让一个或多个进程回退到足以避免死锁的地步，进程回退时自愿释放资源而不是被剥夺，要求系统保持进程的历史信息，设置还原点

## 内存管理

- 分块

  将内存分为几个固定大小的块，每个块中只包含一个进程。若程序运行需要内存，操作系统就分配给它一块，若程序运行只需要很小的空间，分配的这一块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间称为碎片。

- 分段

  把主存分为一段段，每一段的空间又要比一页的空间小很多，但段是有实际意义的，每个段定义了一组逻辑信息，例如有主程序段MAIN，子程序段X，数据段D及栈段S等。段式管理通过段表对应逻辑地址和物理地址。

- 分页

  把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。

  页式管理虽提高了内存利用率，但其中的页实际并无任何实际意义。

  **快表和多级页表**

  分页管理中，很重要的两点：

  1. 虚拟地址到物理地址的转换要快；
  2. 解决虚拟地址空间大，页表也会很大的问题。

  快表：***TODO***

  多级页表：***TODO***

  **分页与分段的共同点和区别**

  - 共同点：
    - 为了提高内存利用率，减少内存碎片
    - 页和段都是离散存储的，两者都是离散分配内存的方式，但页和段中的内存是连续的
  - 区别：
    - 页大小固定，由操作系统决定；段大小不固定，取决于当前运行之程序
    - 分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能更好地满足用户的需要
- 段页式

  结合了段式管理和页式管理的优点。把主存先分为若干段，每个段分为若干页，也即是说段与段之间及段内部是离散的。

## 虚拟内存

计算机系统内存管理的一种技术，可以手动设置。虚拟内存定义了一个连续的虚拟地址空间并把内存扩展到硬盘空间。

虚拟内存使得应用程序认为它拥有连续的可用内存（一个连续的完整内存空间），然而实际上，这个空间通常被分为多个物理内存碎片，甚至有的部分存储在外部磁盘存储器上，需要的时候进行数据交换。

### 局部性原理

***TODO***

### 技术实现

***TODO***

### 页面置换算法

地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断。

> 缺页中断：要访问的页不在主存，需要操作系统将其调入主存后再进行访问。这个时候被内存映射的文件实际上成了一个分页交换文件。

当发生缺页中断时，若当前页面内存中并无空闲页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则称为页面置换算法，可将页面置换算法看成是淘汰页面的规则。

- 最佳页面置换算法（OPT）：所选择的被淘汰的页面将是以后永不使用的，或是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率，但由于无法预知进程在内存下的若干页面中哪个是未来最长时间内不再被访问的，因此该算法无法实现，一般作为衡量其他置换算法的方法
- 先进先出页面置换算法（FIFO）：总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面淘汰
- 最久最近未使用页面置换算法（LRU）：赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间T，当必须淘汰一个页面时，选择现有页面中其T值最大的，即最近最久未使用的页面予以淘汰
- 最少使用页面置换算法（LFU）：选择在之前时期使用最少的页面作为淘汰页
- 时钟置换算法/最近未用算法（NRU）： 为每个页面设置访问位，将内存中的所有页面都通过链接指针链成一个循环队列

## Linux

***TODO***

### 常用命令

***TODO***