# 操作系统

## 内核态&用户态

- 内核态：运行操作系统程序、操作硬件

- 用户态：运行用户程序

### 特权

- 特权指令：只能由操作系统使用、用户程序不能使用的指令（如启动IO、内存清零、设置时钟、停机、修改程序状态字等）
- 非特权指令：用户程序可以使用的指令（如控制转移、取数指令、算数运算等）

特权级别：R0、R1、R2、R3。

R0相当于内核态，R3相当于用户态，不同级别能够运行不同的指令集合。

### 区别

- 处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所占有的处理器是可被抢占的；
- 处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。

### 状态切换

导致切换到内核态的情况：

- 系统调用：用户态进程主动要求切换到内核态的方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作；
- 异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，亦即内核态，如缺页异常；
- 外围设备中断：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的程序，如果先前的指令是用户态下的程序则会发生用户态到内核态的切换，如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

## 进程&线程&协程

- 进程：并发执行程序时资源分配和管理的基本单位，进程中包括可执行代码、打开的文件描述符、挂起的信号、进程的状态、内存地址空间、存放全局变量的数据段，以及一个或多个执行线程等
- 线程：进程中活动的对象，或者说独立调度的基本单位，每个线程都拥有一个独立的程序计数器、线程堆栈和寄存器
- 协程：一种比线程更加轻量级的存在，一个线程也可拥有多个协程；避免了无意义的调度，由此可以提高性能，但程序员必须自己承担调度的责任，同时协程失去了标准使用多CPU的能力

进程与线程的区别：

1. 线程共享本进程的地址空间，而进程之间是独立的地址空间；
2. 线程共享本进程的资源和内存，IO，CPU等，不利于资源的管理和保护，而进程之间是独立的，能很好地进行资源的管理和保护；
3. 多进程比多线程健壮，一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉；
4. 每个独立的进程有一个程序的入口和顺序执行队列，执行开销大；线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程进行控制，执行开销小；
5. 两者均可并发执行；
6. 进程切换时，消耗的资源大，效率低，所以涉及到频繁的切换时，使用线程要好于进程，同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程；
7. 线程是处理器调度的基本单位，进程不是。

线程和协程的区别：

- 线程相对独立，有自己的上下文，切换由系统控制
- 协程相对独立，有自己的上下文，切换由自己控制，当前协程切换到其他协程由当前协程控制

## 上下文切换

当前任务在执行完CPU时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载就是一次上下文切换。

上下文切换通常是计算密集型的，上下文切换对系统来说意味着消耗大量的CPU时间。

## 进程间通信的方式

1. 匿名管道：半双工，具有固定的读端和写端；只能用于父子进程或者兄弟进程之间的进程通信；可以看作是一种特殊的文件，对于它的读写也可以使用普通的read、write函数，但它并不属于任何文件系统，只存在于内存中；
2. 有名管道：可以在无关的进程之间交换数据，与匿名管道不同；有路径名与之关联，以一种特殊的设备文件形式存在于文件系统中；
3. 共享内存：指两个或多个进程共享一个给定存储区，是最快的一种IPC，因为进程是直接对内存进行存取；
4. 信号量：计数器，用于实现进程间的互斥与同步，而非用于存储进程间通信数据，若要在进程间传递数据需要结合共享内存；基于操作系统的PV操作（原子操作），每次对信号量的PV操作不仅限于对信号量值加1或减1，而且可以加减任意正整数；支持信号量组；
5. 消息队列：消息的链接表，存放在内核中，一个消息队列由一个标识符ID来标识；面向记录的，其中的消息具有特定的格式以及特定的优先级；独立于发送与接收进程，进程终止时，消息队列及其内容并不会被删除；可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取；
6. 信号：***TODO***

## 进程调度算法

1. 先来先服务调度算法
2. 短作业优先调度算法
3. 时间片轮转调度算法
4. 多级反馈队列调度算法
5. 最短剩余时间优先调度算法
6. 高响应比优先调度算法
7. 优先级调度算法

## 死锁

指的是多个进程或线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能被正常终止。

### 产生条件

系统中存在一些不可剥夺资源，而当两个或两个以上进程占有自身资源，并请求对方资源时，会导致每个进程都无法向前推进。

1. 互斥：进程或线程要求对所分配的资源进行排他性控制，即在一段时间内某资源仅为一进程所占用
2. 环路等待：在发生死锁时，必然存在一个进程-资源的环形链
3. 请求与保持：当进程因请求资源而阻塞时，对已获得的资源保持不放
4. 不剥夺：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放

### 解决方法

1. 预防死锁
    1. 破坏请求条件：一次性分配所有资源，这样就不会再有请求了
    2. 破坏保持条件：只要有一个资源得不到分配，也不给这个进程分配其他资源
    3. 破坏不可剥夺条件：当某进程获得了部分资源，但得不到其他资源，则释放已占有的资源
    4. 破坏环路等待条件：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反
2. 避免死锁
3. 检测死锁
    1. 银行家算法
4. 解除死锁
    1. 资源剥夺：挂起某些死锁进程，并抢占其资源，将这些资源分配给其他死锁进程（但应该防止被挂起的进程长时间得不到资源）
    2. 撤销进程：强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源（撤销的原则可以按进程优先级和撤销进程代价的高低进行）
    3. 进程回退：让一个或多个进程回退到足以避免死锁的地步，进程回退时自愿释放资源而不是被剥夺，要求系统保持进程的历史信息，设置还原点

## 内存管理

- 分块

  将内存分为几个固定大小的块，每个块中只包含一个进程。若程序运行需要内存，操作系统就分配给它一块，若程序运行只需要很小的空间，分配的这一块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间称为碎片。

- 分段

  把主存分为一段段，每一段的空间又要比一页的空间小很多，但段是有实际意义的，每个段定义了一组逻辑信息，例如有主程序段MAIN，子程序段X，数据段D及栈段S等。段式管理通过段表对应逻辑地址和物理地址。

- 分页

  把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。

  页式管理虽提高了内存利用率，但其中的页实际并无任何实际意义。

  **快表和多级页表**

  分页管理中，很重要的两点：

  1. 虚拟地址到物理地址的转换要快；
  2. 解决虚拟地址空间大，页表也会很大的问题。

  快表：***TODO***

  多级页表：***TODO***

  **分页与分段的共同点和区别**

  - 共同点：
    - 为了提高内存利用率，减少内存碎片
    - 页和段都是离散存储的，两者都是离散分配内存的方式，但页和段中的内存是连续的
  - 区别：
    - 页大小固定，由操作系统决定；段大小不固定，取决于当前运行之程序
    - 分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能更好地满足用户的需要
- 段页式

  结合了段式管理和页式管理的优点。把主存先分为若干段，每个段分为若干页，也即是说段与段之间及段内部是离散的。

## 虚拟内存

计算机系统内存管理的一种技术，可以手动设置。虚拟内存定义了一个连续的虚拟地址空间并把内存扩展到硬盘空间。

虚拟内存使得应用程序认为它拥有连续的可用内存（一个连续的完整内存空间），然而实际上，这个空间通常被分为多个物理内存碎片，甚至有的部分存储在外部磁盘存储器上，需要的时候进行数据交换。

### 局部性原理

***TODO***

### 技术实现

***TODO***

### 页面置换算法

地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断。

> 缺页中断：要访问的页不在主存，需要操作系统将其调入主存后再进行访问。这个时候被内存映射的文件实际上成了一个分页交换文件。

当发生缺页中断时，若当前页面内存中并无空闲页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则称为页面置换算法，可将页面置换算法看成是淘汰页面的规则。

- 最佳页面置换算法（OPT）：所选择的被淘汰的页面将是以后永不使用的，或是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率，但由于无法预知进程在内存下的若干页面中哪个是未来最长时间内不再被访问的，因此该算法无法实现，一般作为衡量其他置换算法的方法
- 先进先出页面置换算法（FIFO）：总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面淘汰
- 最久最近未使用页面置换算法（LRU）：赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间T，当必须淘汰一个页面时，选择现有页面中其T值最大的，即最近最久未使用的页面予以淘汰
- 最少使用页面置换算法（LFU）：选择在之前时期使用最少的页面作为淘汰页
- 时钟置换算法/最近未用算法（NRU）： 为每个页面设置访问位，将内存中的所有页面都通过链接指针链成一个循环队列

## 中断

在CPU执行程序的过程中，出现了某种紧急情况或异常事件时，暂停正在执行的程序，转而去处理该事件，并在处理完该事件之后返回断点处（返回主程序时执行的第一条指令的地址）继续执行刚刚被暂停的程序。

中断源：任何引发中断的事件。 

中断分类：

- 硬件中断（外中断）
    - 非屏蔽中断（NMI，整个系统只有一个）
    - 可屏蔽中断（INTR） 
- 软件中断
    - 除法错误中断
    - 溢出中断
    - 单步中断
    - 断点中断
    - 中断指令`INT n`中断

### 中断处理步骤

1. 中断请求：当某一中断源需要CPU为其进行中断服务时，就输出中断请求信号，使中断控制系统的中断请求触发器置位，向CPU请求中断，系统要求中断请求信号一直保持到CPU对其进行中断响应为止；
2. 中断响应：CPU对系统内部中断源提出的中断请求必须响应，而且自动取得中断服务子程序的入口地址，执行中断服务子程序，对于外部中断，CPU在执行当前指令的最后一个时钟周期去查询INTR引脚，若查到中断请求信号有效，同时在系统开中断（即IF=1）的情况下，CPU向发出中断请求的外设回送一个低电平有效的中断应答信号，作为对中断请求INTR的应答，系统自动进入中断响应周期；
3. 关闭中断：CPU响应中断后，输出中断响应信号，自动将状态标志寄存器FR或EFR的内容压入堆栈保护起来，然后将FR或EFR中的中断标志位IF与陷阱标志位TF清零，从而自动关闭外部硬件中断；由于CPU刚进入中断时要保护现场，主要涉及堆栈操作，此时不能再响应中断，否则将造成系统混乱；
4. 保护断点：将CS和IP/EIP的当前内容压入堆栈保存，以便中断处理完毕后能返回被中断的原程序继续执行，这一过程也是由CPU自动完成；
5. 中断源识别：当系统中有多个中断源时，一旦有中断请求，CPU必须确定是哪一个中断源提出的中断请求，并由中断控制器给出中断服务子程序的入口地址，装入CS和IP/EIP两个寄存器，CPU转入相应的中断服务子程序开始执行；
6. 保护现场：主程序和中断服务子程序都要使用CPU内部寄存器等资源，为使中断处理程序不破坏主程序中寄存器的内容，应先将断点处各寄存器的内容压入堆栈保护起来，再进入的中断处理，现场保护是由用户使用PUSH指令来实现的；
7. 中断服务：中断服务是执行中断的主体部分，不同的中断请求有各自不同的中断服务内容，需要根据中断源所要完成的功能，事先编写相应的中断服务子程序存入内存，等待中断请求响应后调用执行；
8. 恢复现场：当中断处理完毕后，用户通过POP指令将保存在堆栈中的各个寄存器的内容弹出，即恢复主程序断点处寄存器的原值；
9. 中断返回：在中断服务子程序的最后要安排一条中断返回指令IRET，执行该指令，系统自动将堆栈内保存的IP/EIP和CS值弹出，从而恢复主程序断点处的地址值，同时还自动恢复标志寄存器FR或EFR的内容，使CPU转到被中断的程序中继续执行。

## Linux

***TODO***

### 权限管理

***TODO***

### 常用命令

***TODO***