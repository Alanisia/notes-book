# 中间件

## Redis

***TODO***

### 数据类型

|数据类型|可存储的值|操作|应用场景|
|---|---|---|---|
|String|字符串、整数或浮点数|对整个字符串或字符串的其中一部分执行操作<br>对整数和浮点数执行自增或自减操作|简单的键值对缓存|
|List|列表|从两端压入或弹出元素<br>对单个或多个元素进行修剪，只保留一个范围内的元素|存储列表型数据结构|
|Set|无序集合|添加、获取、删除单个元素<br>检查一个元素是否存在于集合中<br>计算交集、并集、差集<br>从集合中随机获取元素|交集、并集、差集的操作|
|Hash|包含键值对的无序散列表|添加、获取、移除单个键值对<br>获取所有键值对<br>检查某个键是否存在|结构化的数据，如对象|
|ZSet|有序集合|添加、获取、删除元素<br>根据分值范围或成员来获取元素<br>计算一个键的排名|去重，排序|

### 应用场景

- 计数器：***TODO***
- 缓存：***TODO***
- 会话缓存：***TODO***
- 全页缓存：***TODO***
- 查找表：***TODO***
- 消息队列：***TODO***
- 分布式锁实现：***TODO***
- 其他操作：***TODO***

### 缓存

**缓存穿透**

使用Redis大部分情况是通过key查询对应的值，加入发送的请求传进来的key是不存在于Redis中的，那么就查不到缓存，会去数据库查询。假如有大量这样的请求，这些请求像”穿透“缓存一样打在数据库上，这种现象唤作缓存穿透。

分析：关键在于传进来的key在Redis中不存在。

解决方案：

1. 把无效的key存进Redis中，如果Redis和数据库都查不到的数据，可以把这个key存进Redis并设置value为null，当下次再通过该key查询时就不会再查数据库，但假如传进来的这个不存在的key每次都是随机的，存进Redis亦无意义；
2. 使用布隆过滤器，若某个key不存在那就一定不存在，若某个key存在那很大可能存在，于是可以在缓存之前再加一层布隆过滤器，在查询时先去布隆过滤器查询key是否存在，若不存在则直接返回。

**缓存雪崩**

当某一个时刻出现大规模的缓存失效的情况，就会导致大量的请求直接打在数据库上面，导致数据库压力巨大，如果在高并发的情况下可能瞬间就会导致数据库宕机。此时如果运维马上重启数据库，马上又会有新的流量打死数据库。

分析：造成缓存雪崩的关键在于在同一时间大规模key失效，有可能是Redis宕机，有可能是采用了相同的过期时间。

解决方案：

1. 在原有的失效时间上加上一个随机值，比如1-5分钟随机，避免因为采用相同的过期时间导致的缓存雪崩；
2. 使用熔断机制，当流量到达一定的阈值时，就直接返回”系统拥挤“之类的提示，防止过多的请求打在数据库上，至少能保证一部分用户是可以正常使用的，其他用户多刷新几次也能得到结果；
3. 提高数据库的容灾能力，可以使用分库分表，读写分离的策略；
4. 为了防止Redis宕机导致缓存雪崩的问题，可以搭建Redis集群，提高Redis的容灾性。

**缓存击穿**

对一个热点的key，有大并发集中对其进行访问，突然该key失效导致大并发全部打在数据库上，导致数据库压力剧增。

分析：关键在于某个热点key失效了，导致大并发集中打在数据库上。可以从两方面解决：

- 是否可以考虑热点key不设置过期时间；
- 是否可以考虑降低打在数据库上的请求数量。

解决方案：

1. 如业务允许，对于热点key可以设置永不过期；
2. 使用互斥锁，如果缓存失效，只有拿到锁才可以查询数据库，降低了在同一时刻打在数据库上的请求，防止数据库打死，当然这样会导致系统的性能变差。

### 持久化

将内存的数据写入磁盘，防止服务宕机导致内存数据丢失。

机制：

1. RDB（默认）

    ***TODO***

2. AOF

    ***TODO***

优缺点：***TODO***

### 过期时间

设置过期时间的命令：`EXPIRE`。

***TODO***

#### 过期键的删除策略

由于缓存的key可以设置过期时间，过期策略讨论的是当缓存的key过期了如何处理的问题。

1. 定时过期 ***TODO***

2. 惰性过期 ***TODO***

3. 定期过期 ***TODO***

### 淘汰策略

***TODO***

### 线程模型

***TODO***

### 事务

***TODO***

### 集群

***TODO***

### 分区

***TODO***

## 消息队列

消息队列解决的核心问题是：异步、削峰、解耦。

缺点：

- 系统可靠性降低，解耦后，多个系统通过消息中间件交互，消息中间件宕机会导致整个系统宕机；
- 系统开发复杂度提升，需要考虑消息的处理，包括消息幂等性（重复消息问题），消息保序性（一条订单多条消息问题），以及消息中间件本身的持久化和稳定性可靠性；
- 消息一致性问题，若一个功能发给多个系统，要所有系统都执行成功才算成功时，需要确保一个功能多个消息的完整一致性。

各种消息队列的比较

|特性|ActiveMQ|RabbitMQ|RocketMQ|Kafka|
|---|---|---|---|---|
|单机吞吐量|万/秒|万/秒|10万/秒|10万/秒|
|topic对吞吐量的影响|无|无|topic达到几百/几千个级别，吞吐量会有小幅下降|topic可达到几十/几百个级别，吞吐量会有大幅下降，不适合大批量topic场景，除非加机器|
|时效性|毫秒|微秒|毫秒|毫秒|
|可用性|高，主从架构|高，主从架构|非常高，分布式|非常高，分布式，数据多副本，不会丢数据，不会不可用|
|可靠性|有较低概率丢失数据||经配置优化可达到0丢失|经配置优化可达到0丢失|
|功能特性|功能齐全，但已不怎么维护|Erlang开发，并发强，性能极好，延迟低|功能较为齐全，扩展好|功能简单，主要用于大数据实时计算和日志采集，事实标准|

### ActiveMQ

- 优点：技术成熟，功能齐全，历史悠久，有大量公司使用
- 缺点：偶尔会有较低概率丢失数据，而且社区已经不怎么维护5.15.X版本
- 使用场景：主要用于系统解耦和异步处理，不适用于大数据量吞吐情况

### RocketMQ

- 优点：支持百千级大规模topic，吞吐量高（十万级，日处理上百亿），接口易用，分布式易扩展
- 缺点：不兼容JMS规范，与阿里（社区）存在绑定
- 使用场景：高吞吐量

### Kafka

分布式消息队列，***TODO***

- 优点：超高吞吐量，超高可用性和可靠性，分布式易扩展
- 缺点：topic支持少，MQ功能简单，消息可能会重复消费影响数据精确度
- 使用场景：超高吞吐量场景而数据精确度没那么高，天然适合大数据实时计算和日志采集场景

### RabbitMQ

***TODO***

- 优点：吞吐量高，功能齐全，管理界面易用，社区活跃，性能极好
- 缺点：吞吐量只是万级，由于是Erlang开发故难以二次开发和掌控，集群动态扩展非常麻烦
- 使用场景：吞吐量不高而要求低延迟，且不会频繁调整和扩展的场景

重要组件：

1. ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器
2. Channel（信道）：消息推送使用的通道
3. Exchange（交换器）：用于接收、分配消息
4. Queue（队列）：用于存储生产者的消息
5. RoutingKey（路由键）：用于把生产者的数据分配到交换器上
6. BindingKey（绑定键）：用于把交换器的消息绑定到队列上

广播模型：

1. fanout：所有绑定到此Exchange的Queue都可以接收消息（很像子网广播，每台子网内的主机都获得了一份复制的消息），fanout交换机转发消息最快
2. direct：通过RoutingKey和Exchange中的BindingKey决定的那个唯一的Queue可以接收消息
3. topic：所有符合RoutingKey所绑定的Queue可以接收消息

#### 模式

- 单机模式：***TODO***
- 普通集群模式：***TODO***
- 镜像集群模式：***TODO***

### RocketMQ

***TODO***

## Druid

***TODO***