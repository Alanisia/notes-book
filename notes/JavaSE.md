# Java基础

## 面向对象

### 特征

- 封装：把数据和操作数据的方法封装起来，对数据的访问只能通过已定义的接口
- 继承：是从已有类得到继承信息创建新类的过程，提供继承信息的类称为父类（超类），得到继承信息的类成为子类（派生类）
- 多态：分为编译时多态和运行时多态
  - 编译时多态（方法重载）：同一个类中同名方法具有不同的参数列表，不能根据返回类型区分（函数调用时不能指定类型信息，编译器不知你要调用哪个函数）
  - 运行时多态（方法重写）：子类重写父类的方法具有相同的返回类型、更好的访问权限；继承父类并重写父类的方法，并用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为

### 与面向过程的区别

面向过程性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源，但没有面向对象易维护、易扩展、易复用。

### 接口和抽象类

区别：

1. 接口方法默认为`public`，所有方法在接口中不能有实现（JDK8开始可以有方法的默认实现），而抽象类可以有非抽象方法；抽象类中的抽象方法可以有`public`，`protected`，`default`修饰符（不能是`private`）
2. 接口中除了`static`，`final`变量，不能有其他变量，抽象类则不一定
3. 一个类能实现多个接口，但只能继承一个抽象类；接口本身可以通过`extends`关键字继承多个接口
4. 从设计层面来说，抽象是对类的抽象，是一种模板设计；而接口是对行为的抽象，是一种行为的规范

## String

**String, StringBuilder, StringBuffer区别**

- `String`不可变
- `StringBuilder`可变，线程不安全，性能好
- `StringBuffer`可变，线程安全，性能较`StringBuilder`差

## 包装类

基本类型`int`, `short`, `char`, `byte`, `boolean`, `long`, `double`, `float`

对应的包装类为`Integer`, `Short`, `Character`, `Byte`, `Boolean`, `Long`, `Double`, `Float`

其中`Integer`, `Short`, `Long`, `Double`, `Float`继承自`Number`

- 自动拆箱：将基本类型用它们的引用类型包装起来
- 自动装箱：将包装类型转换为基本数据类型

## static关键字

***TODO***

## 克隆

- 浅克隆（Shallow Clone）：***TODO***
- 深克隆（Deep Clone）：***TODO***

`Cloneable`接口和`clone()`方法

***TODO***

## 序列化

堆内存中的Java对象数据通过某种方式把对象存储到磁盘文件中，或传递给其他网络节点（网络传输），这个过程称为序列化。通常是指将数据结构或对象转化成二进制的过程，用于保存，或者网络传输。反序列化与序列化相反，即将二进制转化为对象。

序列化的实现：将需要被序列化的类实现`java.io.Serializable`接口

什么时候需要序列化：

1. 把内存中的对象状态保存到文件或数据库的时候
2. 用套接字在网络上传输对象的时候
3. 通过RMI传输对象的时候

### 序列化ID

在进行序列化时加了一个`serialVersionUID`字段，此为序列化ID。

Java序列化机制是通过判断运行时类的`serialVersionUID`来验证版本一致性的，在进行反序列化时，JVM会把穿进来的字节流中的`serialVersionUID`与本地实体类中的`serialVersionUID`进行比较，若相同则认为是一致的，便可以进行反序列化，否则报序列化版本不一致之异常。

默认的序列化ID：若实体类中未显式定义一个名为`serialVersionUID`、类型为`long`的变量时，Java序列化机制会根据编译时的class自动生成一个`serialVersionUID`作为序列化版本比较，此种情况下只有同一次编译生成的class才会生成相同的`serialVersionUID`。如果需求改动，需要在本地类中增加字段，此时再反序列化时会出现`serialVersionUID`不一致导致反序列化失败。

### transient关键字

若变量被`transient`修饰，该变量将不再是对象序列化的一部分，该变量内容在序列化后无法获得访问。

`transient`关键字只能修饰变量，不能修饰方法和类，本地变量亦不能被其修饰。变量若是用户自定义类变量，则该类须实现`Serializable`接口。

另外，静态变量无论是否加上`transient`修饰，均不能被序列化。反序列化后类中的static变量的值为当前JVM中对应的static变量的值，这个值是JVM中的不是反序列化得出的。

## 异常

***TODO***

## 泛型

泛型即“参数化类型”，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式，然后在使用/调用时传入具体类型。

泛型之意义：

1. 适用于多种数据类型执行相同的代码（代码复用）
2. 泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）

### 限定泛型类型变量

- 对类限定：`public class A<T extends Parent> {}`
- 对方法限定：`public static <T extends Parent<T>> T f(T a, T b) {}`

### 通配符

- `<?>`指定了没有限制的泛型类型
- `<? extends Parent>`指定了泛型类型的上界
- `<? super Child>`指定了泛型类型的下界

### 继承原则

- 泛型类可以继承其他泛型类
- 对于泛型参数是继承关系的泛型类之间无继承关系
- 泛型类的继承关系在使用中同样受到泛型类型的影响

### 实现原理

运行期不可见，会进行类型擦除（擦除为上级类型），若无限定之泛型参数类型则擦除为`Object`。

### 约束与局限性

- 不能实例化泛型类
- 静态变量或方法不能引用泛型类型变量，但是静态泛型方法是可以的
- 基本类型无法作为泛型类型
- 无法使用`instanceof`关键字或`==`判断泛型类的类型
- 泛型类的原生类型与所传递的泛型无关，无论传递什么类型，原生类是一样的
- 泛型数组可以声明但无法实例化
- 泛型类不能继承`Exception`或`Throwable`
- 不能捕获泛型类型限定的异常但可以将泛型限定的异常抛出

## 反射

反射是指程序可以访问、检测和修改它本身状态或行为的一种能力。反射允许运行中的Java程序对自身进行检查，并能直接操作程序的内部属性和方法。

实现反射的方法：

1. 通过对象的`getClass()`方法
2. 通过类的`class`对象
3. 通过`Class.forName()`方法

反射API：

1. `Field`：提供有关类的属性信息，以及对它的动态访问权限，是封装反射类的属性的类；
2. `Constructor`：提供有关类的构造方法的信息，以及对它的动态访问权限，是封装反射类的构造方法的类；
3. `Class`：表示正在运行的Java应用程序中的类的实例；
4. `Method`：提供关于类的方法和信息，包括抽象方法，是用来封装反射类方法的一个类；
5. `Object`：所有Java类的父类，所有对象都默认实现了`Object`类的方法。

## 代理

代理模式（Proxy）是通过代理对象访问目标对象，这样可以在目标对象基础上增加额外的功能，如添加权限，访问控制等。

### 静态代理

静态代理模式在不改变目标对象的前提下实现了对目标对象的扩展，但由于静态代理实现了目标对象的所有方法，一旦目标接口增加方法，代理对象和目标对象都要进行相应的修改，增加维护成本。

### 动态代理

1. JDK

    核心接口：

    ```java
    public interface InvocationHandler {
      /**
      * @param proxy 被代理的类实例
      * @param method 调用被代理类的方法
      * @param args 该方法需要的参数
      */
      public Object invoke(
        Object proxy,
        Method method,
        Object[] args
      ) throws Throwable;
    }
    ```

    使用方法：

    实现该接口，重写invoke方法，在invoke方法调用被代理类的方法并获取返回值，并可以在调用方法的前后做一些其他的事情，实现动态代理。

    ```java
    /**
    * @param loader 被代理的类或加载器
    * @param interfaces 被代理类的接口数组
    * @param h 调用处理器类的对象实例
    */
    public static Object newProxyInstance(
      ClassLoader loader,
      Class<?>[] interfaces,
      InvocationHandler h
    ) throws IllegalArgumentException
    ```

    该方法会返回一个被修改过的类的实例，从而可以自由地调用该实例的方法。

2. cglib

    ***TODO***

3. javassist

    ***TODO***