# JVM

## 运行时数据区

1. 程序计数器



   唯一一个不会出现`OutOfMemoryError`的内存区域，它的生命周期随着线程的创建而创建，随着线程的死亡而死亡。

2. 虚拟机栈

   同程序计数器一样，Java虚拟机栈也是线程私有的，生命周期同线程相同，描述Java方法执行的内存模型，每次方法调用的数据都是通过栈传递的。

   Java虚拟机栈由一个个栈帧组成，每个栈帧中拥有：局部变量表、操作数栈、动态链接、方法出口信息。

   局部变量表：主要存放了编译期可知的各种数据类型（基本数据类型）、对象引用。

   会出现两种错误：`StackOverFlowError`和`OutOfMemoryError`。

   - `StackOverFlowError`：虚拟机栈不允许动态扩展，当线程请求栈的深度超过当前栈最大深度时抛出此错误（栈溢出）

   - `OutOfMemoryError`：若堆中无空闲内存，并且垃圾回收器也无法提供更多内存则会抛出此错误

3. 本地方法栈

   本地方法被执行的时候，在本地方法栈会创建一个栈帧，用于存放局部变量表、操作数栈、动态链接、出口信息。方法执行完毕后相应的栈帧会出栈并释放内存空间，也会出现`StackOverFlowError`和`OutOfMemoryError`两种错误。

4. 堆

   被所有内存共享的一块内存区域，在虚拟机启动时创建。此区域存放对象实例，几乎所有对象实例都在这里分配内存。

   Java堆是垃圾收集器管理的主要区域。由于现在的垃圾收集器都采用分代收集算法，因此Java堆又分为新生代、老生代。

5. 方法区(JDK7)

   - 运行时常量池
   - 直接内存



   *注：JDK8废除了方法区改为元空间(MetaSpace)*

线程共享的：

- 堆
- 方法区
- 直接内存

线程私有的：

- 程序计数器
- 虚拟机栈
- 本地方法栈

## 对象创建过程

1. 检查类加载情况
2. 分配内存
3. 初始化零值
4. 初始化对象头
5. 调用\<init\>方法

## GC（垃圾回收）

### 判断是否可以进行垃圾回收的算法

1. 引用计数法

   为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为0，则说明该对象已经死亡，便可以被回收了。

   如果有一个引用被赋值为某一对象，那么将该对象的引用计数+1；如果一个指向某一对象的引用，被赋值为其他值，那么将该对象的引用计数-1。也即是说，我们需要截获所有的引用更新操作，并相应地增减目标对象的引用计数。

   弊端：除了需要额外的空间来存储计数器，以及繁琐的更新操作，引用计数法无法处理循环引用的对象。

2. 可达性分析算法

   将所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点全部找到以后，剩余的节点则被认为是没有被引用到的节点，即无用之节点，会被判定为可回收的对象。

   可作为GC ROOT的对象：

   1. 虚拟机栈中引用的对象（栈帧中的本地变量表）
   2. 方法区中类静态属性引用的对象
   3. 方法区中常量引用的对象
   4. 本地方法栈中JNI（native方法）引用的对象

### 判断常量已废弃



### 判断无用的类

同时满足以下三个条件的类是无用的类：

1. 该类的所有实例都已经被回收
2. 加载该类的ClassLoader已被回收
3. 该类对应的`java.lang.Class`没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

虚拟机**可以**对满足以上三个条件的类进行回收。

### 垃圾收集算法

- 标记-清除算法
- 复制算法
- 标记-整理算法
- 分代收集算法


### 垃圾收集器

- Serial收集器（复制算法）

- Serial Old收集器（标记-整理算法）

- Parallel New收集器（标记-复制算法）

- Parallel Scavenge收集器（标记-复制算法）

- Parallel Old收集器（标记-复制算法）

- CMS(Concurrent Mark Swap)收集器（标记-清除算法）

- G1

### 垃圾回收过程

### 引用

1. 强引用

   在程序代码普遍存在的，类似`Object o = new Object()`这类引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。当内存空间不足，虚拟机宁可抛出`OutOfMemoryError`错误，使程序异常终止，也不会靠随意回收具有强引用对象来解决内存不足的问题。

2. 软引用

   用来描述一些有用但并非必须的对象。软引用需要通过`SoftReference`类来实现，当一个对象只具有软引用时，它有可能被垃圾回收机制回收。

   如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可以用于实现敏感的高速缓存。

   软引用可以和一个引用队列(`ReferenceQueue`)联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会将这个软引用加入到与之关联的引用队列中。

3. 弱引用

   弱引用通过`WeakReference`类实现，弱引用与软引用很像但弱引用比软引用级别更低。

   用来描述非必须对象，强度比软引用更弱一些，被弱引用关联的对象在垃圾回收时，如果这个对象只被弱引用关联（无任何强引用关联它），那么这个对象将会被回收。

   `WeakHashMap`和`ThreadLocal`中使用了弱引用。

4. 虚引用

   虚引用须配合`ReferenceQueue`使用。虚引用不会决定对象的生命周期，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。

   虚引用主要用于跟踪对象被垃圾回收的活动。

_注：在程序设计中一般较少使用弱引用和虚引用，使用软引用情况较多，这是因为软引用可以加速JVM对垃圾回收的回收速度，可以维护系统的运行安全，防止内存溢出(OutOfMemory)等问题产生。_

## Java内存模型(JMM)

Java内存模型(Java Memory Model, JMM)是Java虚拟机规范定义的，用来屏蔽掉Java程序在各种不同的硬件和操作系统对内存的访问的差异，这样就可以实现Java程序在各种不同平台上都能达到内存访问的一致性。

**切莫与[JVM内存模型](#运行时数据区)混淆！**

- 主内存

- 工作内存

JMM规定

1. 所有变量都存储在主内存中；
2. 每条线程还有自己的工作内存；
3. 线程的工作内存总保存了该线程中用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法进行直接访问对方工作内存的变量，线程间变量的传递均需要自己的工作内存和主内存之间进行数据同步进行。

### Java内存模型的实现

1. 原子性

2. 可见性



3. 有序性

   在Java中可以使用`synchronized`和`volatile`关键字来保证多线程之间操作的有序性。`volatile`会禁止指令重排，`synchronized`保证同一时刻只允许一条线程操作。

## JVM监控工具

- jstack：线程快照
- jmap：内存监控
- jps：查看当前Java进程
- jstat：显示虚拟机运行数据
- jinfo：虚拟机配置信息
- jhat：分析heapdump文件
- jvisualvm：虚拟机监视和故障处理平台