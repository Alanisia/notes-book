# JVM

## 运行时数据区

线程共享的：

- 堆
- 方法区
- 直接内存

线程私有的：

- 程序计数器
- 虚拟机栈
- 本地方法栈

1. 程序计数器

   一块较小的内存空间，可以看作是当前当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。

   为了线程切换后可以回到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程的计数器之间互不影响，独立存储。

   唯一一个不会出现`OutOfMemoryError`的内存区域，它的生命周期随着线程的创建而创建，随着线程的死亡而死亡。

2. 虚拟机栈

   同程序计数器一样，Java虚拟机栈也是线程私有的，生命周期同线程相同，描述Java方法执行的内存模型，每次方法调用的数据都是通过栈传递的。

   Java虚拟机栈由一个个栈帧组成，每个栈帧中拥有：局部变量表、操作数栈、动态链接、方法出口信息。

   局部变量表：主要存放了编译期可知的各种数据类型（基本数据类型）、对象引用。

   会出现两种错误：`StackOverFlowError`和`OutOfMemoryError`。

   - `StackOverFlowError`：虚拟机栈不允许动态扩展，当线程请求栈的深度超过当前栈最大深度时抛出此错误（栈溢出）

   - `OutOfMemoryError`：若堆中无空闲内存，并且垃圾回收器也无法提供更多内存则会抛出此错误

3. 本地方法栈

   本地方法被执行的时候，在本地方法栈会创建一个栈帧，用于存放局部变量表、操作数栈、动态链接、出口信息。方法执行完毕后相应的栈帧会出栈并释放内存空间，也会出现`StackOverFlowError`和`OutOfMemoryError`两种错误。

4. 堆

   被所有内存共享的一块内存区域，在虚拟机启动时创建。此区域存放对象实例，几乎所有对象实例都在这里分配内存。

   Java堆是垃圾收集器管理的主要区域。由于现在的垃圾收集器都采用分代收集算法，因此Java堆又分为新生代、老生代。

5. 方法区(JDK7)

   - 运行时常量池
   - 直接内存

      ***TODO***

   *注：JDK8废除了方法区改为元空间(MetaSpace)*

## 对象创建过程

1. 检查类加载情况
2. 分配内存
3. 初始化零值
4. 初始化对象头
5. 调用\<init\>方法

## 类加载

### 类加载器（ClassLoader）

***TODO***

### 双亲委派

***TODO***

## GC（垃圾回收）

### 判断是否可以进行垃圾回收的算法

1. 引用计数法

   为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为0，则说明该对象已经死亡，便可以被回收了。

   如果有一个引用被赋值为某一对象，那么将该对象的引用计数+1；如果一个指向某一对象的引用，被赋值为其他值，那么将该对象的引用计数-1。也即是说，我们需要截获所有的引用更新操作，并相应地增减目标对象的引用计数。

   弊端：除了需要额外的空间来存储计数器，以及繁琐的更新操作，引用计数法无法处理循环引用的对象。

2. 可达性分析算法

   将所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点全部找到以后，剩余的节点则被认为是没有被引用到的节点，即无用之节点，会被判定为可回收的对象。

   可作为GC ROOT的对象：

   1. 虚拟机栈中引用的对象（栈帧中的本地变量表）
   2. 方法区中类静态属性引用的对象
   3. 方法区中常量引用的对象
   4. 本地方法栈中JNI（native方法）引用的对象

### 判断常量已废弃

***TODO***

### 判断无用的类

同时满足以下三个条件的类是无用的类：

1. 该类的所有实例都已经被回收
2. 加载该类的ClassLoader已被回收
3. 该类对应的`java.lang.Class`没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

虚拟机**可以**对满足以上三个条件的类进行回收。

### 垃圾收集算法

- 标记-清除(Mark-Sweep)算法

   采用从根集合（GC Roots）进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收。

   不需要进行对象的移动，只需对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于直接回收不存活对象，因此会造成内存碎片。

- 复制(Copying)算法

   将可用内存按容量划分成大小相等的两块，每次只使用其中的一块，当这一块内存用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。

   在存活对象较多的情况下就要执行较多次的复制操作，效率将会降低。并且该算法会使得50%的内存空间被浪费。

   现代商业虚拟机都是使用这种算法来回收新生代，不过不需要按照1：1的比例来划分内存空间。

- 标记-整理(Mark-Compact)算法

   采用标记-清除算法一样的方式进行对象标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新相应的指针。与标记-清除算法相比成本更高，但解决了内存碎片的问题。

- 分代收集(Generational Collection)算法

   根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代、新生代，在堆区外还有一个永久代。

   老年代的特点是每次垃圾回收时只有少量的对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最合适的收集算法。

   1. 年轻代的回收算法

      所有新生代的对象首先都是放在年轻代的，年轻代的目标就是尽可能地回收掉那些生命周期短的对象。

      新生代内存按照8:1:1的比例分为一个Eden区和两个Survivor区（survivor0，survivor1），大部分对象在Eden区生成，回收时先将Eden区存活对象复制到survivor0区（对象年龄初始化为1），然后清空Eden区。当survivor0区也存放满了时，则将Eden区和survivor0区存活对象复制到另一个survivor1区（对象年龄+1），然后清空Eden区和survivor0区，此时survivor0区是空的，然后survivor0和survivor1互换，保持survivor1区为空，如此往复。

      当survivor1区不足存放Eden区和survivor0区的存活对象时，就将存活对象直接存放入老年代。若是老年代也满了就会触发一次Full GC（Major GC），也就是新生代、老生代均进行垃圾回收。

      新生代发生的GC叫Minor GC，Minor GC发生频率较高（不一定等Eden区满才触发）。

   2. 年老代的回收算法

      在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放入老年代中。当对象的年龄达到一定程度时（默认15），就会晋升到老年代。因此，可以认为老年代中存放的都是一些生命周期较长的对象。

      内存比新生代大很多（比例大概1：2），当老年代满时触发Full GC，Full GC发生频率较低，老年代对象存活时间比较长，存活率标记高。

### 垃圾收集器

- Serial收集器（复制算法）

   单线程收集器

- Serial Old收集器（标记-整理算法）

- ParNew收集器（标记-复制算法）

- Parallel Scavenge收集器（标记-复制算法）

- Parallel Old收集器（标记-复制算法）

- CMS(Concurrent Mark Swap)收集器（标记-清除算法）

   运作过程分为四个步骤：

   1. 初始标记（CMS initial mark）：记录下直接与GC Root相连的对象，暂停所有其他线程，速度很快；
   2. 并发标记（CMS concurrent mark）：同时开启GC和用户线程，用一个闭包结构去记录可达对象，但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象，因为用户线程可能会不断更新作用域，所以GC线程无法保证可达性分析的实时性，所以这个算法里会跟踪记录这些发生引用更新的地方；
   3. 重新标记（CMS remark）：为了修正并发标记期间因用户程序继续运行而导致标记发生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始阶段的时间稍长，远远比并发标记阶段时间短；
   4. 并发清除（CMS concurrent sweep）：开启用户线程，同时GC线程开始对未标记的区域做清扫。

   其中初始标记和重新标记需要“stop the world”。

   CMS优点：

   1. 并发收集
   2. 低停顿

   CMS缺点：

   1. 对CPU资源非常敏感
   2. 无法处理浮动垃圾
   3. 收集结束时会产生大量内存碎片
   
      _浮动垃圾：_

- G1(Garbage First)收集器

### 垃圾回收策略

- Minor GC

   发生在新生代的垃圾收集动作。

   大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。

   由于大多数Java对象大多具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也较快。

- Full GC(Major GC)

   发生在老年代的GC。出现了Full GC，经常伴随至少一次Minor GC（非绝对）。Full GC的速度一般会比Minor GC慢10倍以上。

### 垃圾回收过程

***TODO***

### 引用

1. 强引用

   在程序代码普遍存在的，类似`Object o = new Object()`这类引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。当内存空间不足，虚拟机宁可抛出`OutOfMemoryError`错误，使程序异常终止，也不会靠随意回收具有强引用对象来解决内存不足的问题。

2. 软引用

   用来描述一些有用但并非必须的对象。软引用需要通过`SoftReference`类来实现，当一个对象只具有软引用时，它有可能被垃圾回收机制回收。

   如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可以用于实现敏感的高速缓存。

   软引用可以和一个引用队列(`ReferenceQueue`)联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会将这个软引用加入到与之关联的引用队列中。

3. 弱引用

   弱引用通过`WeakReference`类实现，弱引用与软引用很像但弱引用比软引用级别更低。

   用来描述非必须对象，强度比软引用更弱一些，被弱引用关联的对象只会生存到下一次垃圾回收之前。垃圾回收器工作时，无论当前内存是否足够，如果这个对象只被弱引用关联（无任何强引用关联它），那么这个对象将会被回收。

   `WeakHashMap`和`ThreadLocal`中使用了弱引用。

4. 虚引用

   一个对象是否有虚引用的存在，完全不会对其生存时间产生影响，也无法通过虚引用来获得一个对象实例。

   虚引用须配合`ReferenceQueue`使用。虚引用不会决定对象的生命周期，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。

   虚引用主要用于跟踪对象被垃圾回收的活动。

_注：在程序设计中一般较少使用弱引用和虚引用，使用软引用情况较多，这是因为软引用可以加速JVM对垃圾回收的回收速度，可以维护系统的运行安全，防止内存溢出(OutOfMemory)等问题产生。_

## Java内存模型(JMM)

Java内存模型(Java Memory Model, JMM)是Java虚拟机规范定义的，用来屏蔽掉Java程序在各种不同的硬件和操作系统对内存的访问的差异，这样就可以实现Java程序在各种不同平台上都能达到内存访问的一致性。

**切莫与[JVM内存模型](#运行时数据区)混淆！**

- 主内存

***TODO***

- 工作内存

***TODO***

JMM规定

1. 所有变量都存储在主内存中；
2. 每条线程还有自己的工作内存；
3. 线程的工作内存总保存了该线程中用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法进行直接访问对方工作内存的变量，线程间变量的传递均需要自己的工作内存和主内存之间进行数据同步进行。

### Java内存模型的实现

1. 原子性

***TODO***

2. 可见性

***TODO***

3. 有序性

   在Java中可以使用`synchronized`和`volatile`关键字来保证多线程之间操作的有序性。`volatile`会禁止指令重排，`synchronized`保证同一时刻只允许一条线程操作。

## JVM监控工具

- jstack：线程快照
- jmap：内存监控
- jps：查看当前Java进程
- jstat：显示虚拟机运行数据
- jinfo：虚拟机配置信息
- jhat：分析heapdump文件
- jvisualvm：虚拟机监视和故障处理平台