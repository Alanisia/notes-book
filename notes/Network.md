# 计算机网络

## OSI & TCP/IP

- OSI的体系结构（七层）：

    自上而下：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层

- TCP/IP的体系结构（四层）：

    自上而下：应用层、传输层、网际层、网络接口层

- TCP/IP的体系结构（五层）：

    自上而下：应用层、传输层、网络层、数据链路层、物理层

各层的作用：

1. 应用层

    ***TODO***

2. 传输层

    ***TODO***

3. 网络层

    ***TODO***

4. 数据链路层

    ***TODO***

5. 物理层

    ***TODO***

## TCP

TCP如何保证可靠传输：

***TODO***

### ARQ

***TODO***

### 流量控制

***TODO***

### 拥塞控制

***TODO***

### 三次握手

刚开始客户端和服务端均处于CLOSED状态，客户端主动打开连接，服务端被动打开连接，此时服务端处于LISTEN状态。

第一次：客户端给服务端发一个SYN报文，并设置一个序列号。此时客户端进入SYN_SEND状态。

第二次：服务端收到客户端的SYN报文后，以自己的SYN报文作为应答，并指定一个序列号；同时将客户端的序列号+1作为ACK的值，表示自己已收到客户端的SYN报文，此时服务端处于SYN_RCVD状态。

第三次：客户端收到SYN报文后，会发送一个ACK报文，并将服务端报文的序列号+1作为自己的ACK的值，而自己的序列号为第二次握手时客户端ACK报文段的确认号，此时客户端处于ESTABLISHED状态。服务端在收到报文后也进入ESTABLISHED状态，双方建立连接。

**为什么客户端要再发一次确认？**

防止已失效的连接请求报文段突然又传到服务端导致发生错误。

_已失效的连接请求报文段：***TODO***_

### 四次挥手

刚开始双方均处于ESTABLISHED状态，客户端发起关闭请求，

第一次：客户端发送一个FIN报文，报文中指定一个序列号，此时客户端处于FIN_WAIT_1状态。

第二次：服务端收到FIN报文后，会发送ACK报文，确认号指定为客户端FIN报文的序列号+1，同时指定自己的序列号，此时服务端处于CLOSE_WAIT状态。客户端收到来自服务端的确认后进入FIN_WAIT_2状态。

第三次：服务端发出FIN报文，报文指定一个序列号，确认号与第二次挥手时发送给客户端的确认报文一样，此时服务端进入LACK_ACK状态。

第四次：客户端收到服务端的FIN报文后，会发送ACK报文，确认号为服务端FIN报文的序列号+1，自己的序列号指定为第一次挥手时发送给服务端的FIN报文的序列号+1，然后进入TIME_WAIT状态。此时连接仍未释放，须经过时间等待计时器设置的时间2MSL后才进入CLOSED状态。

**为什么要等待2MSL？**

1. 为了保证客户端发送的最后一个ACK报文断到达服务端；
2. 防止已失效的连接请求报文段出现在本连接中。

**为什么要四次？**

***TODO***

## UDP

***TODO***

## HTTP

***TODO***

### 状态码

|状态码|类别|原因短语|
|----|----|----|
|1XX|Informational（信息性）|接收的请求正在处理|
|2XX|Success（成功）|请求正常处理完毕|
|3XX|Redirection（重定向）|需要进行附加操作以完成请求|
|4XX|Client Error（客户端错误）|服务器无法处理请求|
|5XX|Server Error（服务端错误）|服务器处理请求出错|

### HTTP/1.0 & HTTP/1.1

两者区别：

1. 长连接

2. 错误状态响应码

3. 缓存处理

4. 带宽优化及网络连接的使用

### HTTPS

***TODO***

### HTTP长连接和短连接

- 短连接：
- 长连接：

HTTP/1.0默认使用短连接。

HTTP/1.1默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加上这行代码：

```http
Connection:keep-alive
```

HTTP的短连接和长连接，实质上是TCP的长连接和短连接。

## Session/Cookie

***TODO***

## DNS

***TODO***

## 浏览器输入URL到显示页面的过程

1. 浏览器查找域名对应的IP地址

2. 浏览器向WEB服务器发送一个HTTP请求

3. 服务器处理请求

4. 服务器返回一个HTTP响应

5. 浏览器显示HTML
