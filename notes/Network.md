# 计算机网络

## OSI & TCP/IP

- OSI的体系结构（七层）：

    自上而下：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层

    各层的作用：

    1. 应用层：为用户的应用程序提供网络服务
    2. 表示层：将信息表示为一定形式和格式的数据流
    3. 会话层：负责通信主机之间的会话的建立、管理和拆除，协调通信双方的会话
    4. 传输层：负责通信主机间端到端的连接
    5. 网络层：负责将分组从源主机送到目的主机，包括寻址和最优路径选择等
    6. 数据链路层：提供可靠的帧传递，实现差错控制、流控等
    7. 物理层：提供透明的比特流传递

- TCP/IP的体系结构（四层）：

    自上而下：应用层、传输层、网际层、网络接口层

- TCP/IP的体系结构（五层）：

    自上而下：应用层、传输层、网络层、数据链路层、物理层

    各层的作用：

    1. 应用层：通过应用进程间的交互来完成特定的网络应用。应用层协议定义的是应用进程间的通信和交互规则。对于不同的网络应用需要不同的应用层协议。
    2. 传输层：负责两台主机进程间的通信提供通用的数据传输服务，应用进程利用该服务传输应用层报文。
    3. 网络层：在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换节点，确保数据及时传送。
    4. 数据链路层：两台主机之间的数据传输，总是在一段一段的链路上传输的，这就需要专门的链路层协议。在两个相邻节点传送数据时，链路层将网络层交下来的IP数据报封装成帧，在两个相邻节点间的链路传送帧，每一帧包含数据和必要的控制信息（如同步信息，地址信息，差错控制等）。
    5. 物理层：实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。

## 网络层

### IP地址

IP地址可定义为：{<网络号>，<主机号>}

IP地址分类：

|类别|类别位|网络号字节长|主机号字节长|单播或多播|
|---|---|---|---|---|
|A|0(1-126)|1|3|单播|
|B|10(128-191)|2|2|单播|
|C|110(192-223)|3|1|单播|
|D|1110(224-239)|||多播|
|E|1111(240-255)||||

IP地址指派范围：

|网络类别|最大可指派的网络数|第一个可指派的网络号|最后一个可指派的网络号|每个网络中的最大主机数|
|---|---|---|---|---|
|A|126 ($2^7 - 2$)|1|126|16777214|
|B|16383 ($2^{14} - 1$)|128.1|191.255|65534|
|C|2097151 ($2^{21} - 1$)|192.0.1|223.255.255|254|

### 子网掩码

***TODO***

## UDP

用户数据报协议，是OSI参考模型中一种无连接传输层协议，提供面向事务的简单的不可靠信息传输服务。

特点：

- 无连接，发送数据前不需建立连接，发送数据后亦不需释放连接
- 面向报文
- 尽最大努力交付
- 无拥塞控制
- 首部开销小，只有8个字节
- 支持一对一、一对多、多对多的交互通信

_注：UDP不存在拆包粘包现象，是因为UDP有消息保护边界。UDP对应用层交下来的报文既不合并也不拆分，而是保留这些报文的边界，一次交付一个完整的报文。_

### 首部格式

首部只有8个字节，由4个字段组成，每个字段2个字节。

|字段|字段意义|
|---|---|
|源端口|在需要对方回信时选用，不需要时可用全0|
|目的端口|这在终点交付报文时必须使用|
|长度|UDP用户数据报的长度，其最小值是8（仅有首部）|
|检验和|检测UDP用户数据报在传输中是否有错，有错就丢弃|

## TCP

特点：

1. 面向连接
2. 提供全双工通信
3. 只支持点对点（一对一）通信
4. 提供可靠交付服务
5. 面向字节流

TCP如何保证可靠传输：

1. 数据包校验
2. 对失序数据包重排序
3. 丢弃重复数据
4. 应答机制
5. 超时重发
6. 流量控制

### ARQ

***TODO***

自动重传请求ARQ协议

连续ARQ协议

### 流量控制

TCP利用滑动窗口来实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为0，则发送方不能发送数据。

> **滑动窗口**
>
> 一种流量控制技术，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为0时，发送方一般不能再发送数据报，但有两种情况除外，一种是可以发送紧急数据，另一种是发送方可以发送一个1字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。

### 拥塞控制

***TODO***

### 三次握手

刚开始客户端和服务端均处于CLOSED状态，客户端主动打开连接，服务端被动打开连接，此时服务端处于LISTEN状态。

第一次：客户端给服务端发一个SYN报文，并设置一个序列号。此时客户端进入SYN_SEND状态。

第二次：服务端收到客户端的SYN报文后，以自己的SYN报文作为应答，并指定一个序列号；同时将客户端的序列号+1作为ACK的值，表示自己已收到客户端的SYN报文，此时服务端处于SYN_RCVD状态。

第三次：客户端收到SYN报文后，会发送一个ACK报文，并将服务端报文的序列号+1作为自己的ACK的值，而自己的序列号为第二次握手时服务端ACK报文段的确认号，此时客户端处于ESTABLISHED状态。服务端在收到报文后也进入ESTABLISHED状态，双方建立连接。

**为什么客户端要再发一次确认？**

防止已失效的连接请求报文段突然又传到服务端导致发生错误。

_已失效的连接请求报文段：***TODO***_

### 四次挥手

刚开始双方均处于ESTABLISHED状态，客户端发起关闭请求，

第一次：客户端发送一个FIN报文，报文中指定一个序列号，此时客户端处于FIN_WAIT_1状态。

第二次：服务端收到FIN报文后，会发送ACK报文，确认号指定为客户端FIN报文的序列号+1，同时指定自己的序列号，此时服务端处于CLOSE_WAIT状态。客户端收到来自服务端的确认后进入FIN_WAIT_2状态。

第三次：服务端发出FIN报文，报文指定一个序列号，确认号与第二次挥手时发送给客户端的确认报文一样，此时服务端进入LACK_ACK状态。

第四次：客户端收到服务端的FIN报文后，会发送ACK报文，确认号为服务端FIN报文的序列号+1，自己的序列号指定为第一次挥手时发送给服务端的FIN报文的序列号+1，然后进入TIME_WAIT状态。此时连接仍未释放，须经过时间等待计时器设置的时间2MSL后才进入CLOSED状态。

**为什么要等待2MSL？**

1. 为了保证客户端发送的最后一个ACK报文段到达服务端；
2. 防止已失效的连接请求报文段出现在本连接中。

**为什么要四次？**

***TODO***

### 拆包与粘包

_注：TCP是面向字节流的协议，没有“包”的概念，说“拆包”和“粘包”是为了有助于形象地理解这两种现象。_

- 拆包：如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP会将其拆分为多次发送
- 粘包：如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP会将多个请求合并为同一个进行发送

**解决方法**

- 发送端将每个包都封装成固定的长度
- 发送端在每个包末尾使用固定的分隔符，如`\r\n`，若发生拆包则需要等待多个包发送过来之后找到其中的`\r\n`进行合并
- 将消息分为消息头和消息体，头部保存整个消息的长度，只有读取到足够长度的消息才能算是读到了完整的消息
- 通过自定义协议进行处理

### 短连接与长连接

TCP在进行读写之前，server与client必须提前建立一个连接，建立连接的过程便是三次握手，释放/关闭连接需要四次挥手，这个过程比较消耗网络资源且有时间延迟。

- 短连接：Server与Client建立连接后，读写完成后就关闭连接，下次再要互相发送消息需要重新连接

    短连接实现和管理都比较简单，但每一次读写都建立连接必然会带来大量网络资源的消耗，且建立连接也耗费时间。

- 长连接：Server与Client建立连接后，即使Client与Server完成一次读写，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接

    长连接可以省去较多的TCP建立和关闭的操作，降低对网络资源的依赖，节约时间，对于频繁请求资源的用户来说非常适用长连接。

### 心跳机制

在TCP保持长连接的过程中，可能会出现断网等网络异常情况，异常发生的时候，client和server之间若无交互，双方将无法发现对方已经掉线。为了解决这个问题引入了心跳机制。

Client和Server之间在一定时间内无数据交互时，即处于idle状态时，客户端或服务器就会发送一个特殊的数据包给对方，当接收方收到这个数据报文后，也立即发送一个特殊的数据报文回应发送方，此即一个PING-PONG交互。所以当某一端收到心跳消息后，就知道对方仍然在线，这就确保了TCP连接的有效性。

TCP实际自带长连接选项，本身亦有心跳包机制，也即TCP选项SO_KEEPALIVE。不过TCP层面的长连接灵活性不够，所以一般情况下都是在应用层协议上实现自定义心跳机制。

## HTTP

***TODO***

HTTP请求类型：

- GET：请求从服务器获取特定资源
- POST：在服务器上创建一个新的资源
- PUT：更新服务器上的资源（客户端提供更新后的整个资源）
- DELETE：从服务器删除特定的资源
- HEAD：获取报文首部，和GET类似但不返回报文实体主体部分
- OPTIONS：查询指定URL支持的方法
- PATCH：对资源进行部分修改，PUT亦可用于修改资源，但只能完全替代原始资源
- TRACE：追踪路径，服务器会将通信路径返回给客户端
- CONNECT：要求在与代理服务器通信时建立隧道

### 状态码

|状态码|类别|原因短语|
|----|----|----|
|1XX|Informational（信息性）|接收的请求正在处理|
|2XX|Success（成功）|请求正常处理完毕|
|3XX|Redirection（重定向）|需要进行附加操作以完成请求|
|4XX|Client Error（客户端错误）|服务器无法处理请求|
|5XX|Server Error（服务端错误）|服务器处理请求出错|

### HTTP/1.0 & HTTP/1.1

两者区别：

1. 长连接

2. 错误状态响应码

3. 缓存处理

4. 带宽优化及网络连接的使用

### HTTP长连接和短连接

HTTP/1.0默认使用短连接。

HTTP/1.1默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加上这行代码：

```http
Connection:keep-alive
```

HTTP的短连接和长连接，实质上是TCP的长连接和短连接。

### HTTPS

HTTPS是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议。

#### 工作过程

1. 客户端发送自己支持的加密规则给服务器；
2. 服务器从中选出一套加密算法和hash算法以及自己的身份信息以证书的形式发送给浏览器，证书中包含服务器信息，加密公钥，证书机构；
3. 客户端将验证证书的合法性，如果验证通过证书，浏览器会生成一串随机数，并用证书中的公钥加密；之后用约定好的hash算法计算握手信息，然后用生成的密钥进行加密，一起发送给服务器；
4. 服务器接收到客户端传来的信息，用私钥解析出密码，用密码解析握手消息，验证hash值是否和浏览器发来的一致；使用密钥加密消息；
5. 如果计算hash值一致则握手成功。

#### 与HTTP的区别

1. 开销：HTTPS协议需要到CA申请证书，一般免费证书少，需要交费；
2. 资源消耗：HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的SSL加密传输协议，需要消耗更多的CPU和内存资源；
3. 端口不同：HTTP的端口是80，HTTPS的端口是443；
4. 安全性：HTTP连接简单，无状态；HTTPS是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，较HTTP安全。

#### 优缺点

优点：

1. 可认证用户和服务器，确保数据发送到正确的客户机和服务器
2. 比较安全，可防止数据在传输过程中不被窃取、改变，确保数据完整性
3. 大幅增加了中间人攻击的成本

缺点：

1. 握手阶段费时
2. SSL证书需要交费，功能越强的证书费用越高
3. SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名
4. 缓存不如HTTP高效，会增加数据的开销和功耗，甚至已有的安全措施会因此受到影响
5. 加密范围比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到作用
6. SSL证书的信用链体系不完全

### Session/Cookie/Token

Session和Cookie：

由于HTTP的无状态性，为了使某个域名下的所有网页能够共享某些数据，出现了session和cookie，客户端访问服务器的流程如下：

1. 客户端发送一个HTTP请求到服务端；
2. 服务端接收到请求后，建立一个session，并发送一个HTTP响应到客户端，响应头包括Set-Cookie头部，该头部包含了sessionId；
3. 在客户端发起的第二次请求，加入服务端给了Set-Cookie，浏览器会自动在请求头中添加cookie；
4. 服务端接收请求，分解cookie，验证信息，核对成功后返回响应给客户端。

_注意：**TODO**_

Token（令牌）认证方式类似于临时的证书签名，并且是一种服务端无状态的认证方式，非常适合于Restful API的场景，所谓无状态即是服务端不会保存身份认证相关的数据。

Token组成：

- uid，用户唯一身份标识
- time，当前时间的时间戳
- sign，签名，使用hash/encrypt压缩成定长的十六进制字符串，以防止第三方恶意拼接
- 固定参数（可选），将一些常用的固定参数加入到token中是为了避免重复查库

Token存放：在客户端一般存放于`localStorage`，`cookie`，`sessionStorage`中；在服务器一般存放于数据库中。

Token认证流程：

1. 用户登录，成功后服务器返回token给客户端；
2. 客户端受到数据后保存在客户端；
3. 客户端再次访问服务器，将token放入headers中；
4. 服务器端采用过滤器校验，校验成功则返回请求数据，校验失败则返回错误码。

_注：Token可以抵抗CSRF攻击，攻击者无法访问用户的token，浏览器不会自动添加到headers里，提交的表单无法通过服务器过滤，无法形成攻击。_

## DNS

域名解析协议。

***TODO***

## 浏览器输入URL到显示页面的过程

1. 浏览器查找域名对应的IP地址
    
    浏览器查询DNS，获取域名对应的IP地址。具体过程包括浏览器搜索自身的DNS缓存、操作系统的DNS缓存、读取本地的hosts文件和向本地DNS服务器进行查询等。

2. 浏览器向WEB服务器发送一个HTTP请求

    浏览器获得域名对应的IP地址后，向服务器请求建立连接，发起三次握手。TCP连接建立后，浏览器向服务器发送HTTP请求。

3. 服务器处理请求，返回一个HTTP响应

    服务器收到请求，根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器。

4. 浏览器解析并渲染页面

    浏览器解析并渲染视图，若遇到对JS、CSS文件及图片等静态资源的引用，则重复上述步骤并向服务器请求资源；浏览器根据请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。

## 网络攻击

1. CSRF/XSRF：跨站域请求伪造，***TODO***

2. XSS（Cross Site Scripting）：跨站脚本攻击，利用网站漏洞从用户恶意盗取信息（静态站点不会受其影响）

3. SQL注入