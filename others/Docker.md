# Docker

容器是一种轻量级、可移植的为应用程序提供了隔离的运行空间，每个容器内部都包含了一个独享的完整用户环境，并且一个容器内的环境变动不会影响其他容器的运行环境，可以使应用程序在几乎任何地方以相同的方式运行。技术方面，容器通过一系列系统级别的机制来实现。

Docker是一个容器化平台，它以容器的形式将应用程序及其所有依赖项打包在一起，以确保应用程序在开发、测试或生产的任何环境中无缝运行。Docker将一个软件包装在一个完整的文件系统中，该文件系统包含运行所需之一切：代码、运行时、系统工具、系统库等可以安装在服务器上的任何东西，这可以保证软件始终运行相同，无论起环境如何。

Docker的优势：

- 开发方面：切换项目工程时可以自动化修改和设置开发环境，让开发人员更加专注于软件质量
- 运维方面：在开发、测试和生产环境均使用相同镜像，实现自动化的编译、打包、测试和部署
- 容器和虚拟机方面：使容器与虚拟机相结合，部署和管理应用变得更加灵活

使用Docker构建与环境无关之系统，有三个主要功能有助于实现此目标：

- Volumes
- 环境变量注入
- 只读文件系统

## 架构

Docker引擎组件：

- 后台服务：长时间运行在后台的守护进程
- REST接口：程序可以通过REST接口来访问后台服务或向它发送操作指令
- 交互式命令行界面

Docker是C/S架构，客户端通过与后台服务交互，来编译、运行和发布容器。Docker的客户端可以连接到本地或远程的Docker服务上，使用REST接口与后台服务通信（利用UNIX Socket或网络接口实现）。

- 后台服务监听REST接口的请求，管理Docker对象，一个后台服务可以和其他后台服务进行通信，从而对其进行管理
- Docker Client（客户端）：与后台服务交互的主要工具
- Docker Registry（仓库）：存储Docker镜像，Docker默认从Docker Hub下载镜像
- Docker Object（对象）：包括镜像、容器、网络、磁盘卷和插件等
- Namespaces（命名空间）：为容器提供隔离，使容器仅限与在自己的命名空间中访问

## Image（镜像）

Docker容器的源代码，用于创建容器。使用`build`命令构建镜像，并且在使用`run`启动时将生成容器。镜像存储在Docker注册表`registry.hub.docker.com`中，因为它们可能变得非常大，镜像被设计为由其他镜像层构成，允许在通过网络传输镜像时发送最少量的数据。

## Container（容器）

Docker容器包括应用程序及其所有依赖项，但与其他容器共享内核，作为主机操作系统上用户空间中的独立进程运行，不依赖于任何特定的基础架构，可以在任何计算机、任何基础架构和任何云中运行。

状态：

- 运行
- 已暂停
- 重新启动
- 已退出

可以通过`docker ps -a`依次列出所有可用的容器及其在主机上的相应状态。

## Dockerfile

用来构建镜像的文本文件，包含构建镜像所需的指令和说明。在Dockerfile文件的存放目录下执行构建动作：

```bash
docker build -t <name>:<tag> . # "."代表上下文路径
```

指令：
- `FROM`：定制的镜像都是基于`FROM`的镜像，即指定基础镜像
- `RUN`：用于执行后面跟着的命令行命令，有两种格式：
  - Shell：`RUN <COMMAND>`
  - Exec：`RUN ["<EXE>", "[ARGS ... ]"]`
- `COPY`：复制指令，从上下文目录中复制文件或者目录到容器中的指定路径，格式：`COPY [--chown=<user>:<group>] <SRC1>, ... <DEST>`
- `ADD`：与`COPY`类似，不同之处在于：
  - `ADD`优点：在执行源文件为tar压缩文件，压缩格式为gzip、bzip2以及xz的情况下会自动复制并解压到目标路径
  - `ADD`缺点：在不解压的前提下，无法复制tar压缩文件，会令镜像构建失败，从而可能会令镜像构建变得比较缓慢，具体是否使用，可以根据是否需要自动解压来决定
- `CMD`：与`RUN`类似，用于运行程序，但二者运行的时间点不同：
  - `CMD`：`docker run`时运行
  - `RUN`：`docker build`时运行
  为启动的容器指定默认要运行的程序，程序运行结束，容器结束，`CMD`指令指定的程序可被`docker run`命令行参数中指定要运行的程序所覆盖；另，如果Dockerfile中存在多个`CMD`指令，仅最后一个生效
- `ENTRYPOINT`：***TODO***