# Go

## 基本类型

|类型|长度（字节）|默认值|说明|
|---|---|---|---|
|`bool`|1|`false`||
|`byte`|1|0|`uint8`|
|`rune`|4|0|Unicode Code Point, `int32`|
|`int`, `uint`|4/8|0|32/64位|
|`int8`, `uint8`|1|0|-128~127/0~255（C: `short`）|
|`int16`, `uint16`|2|0|-32768~32767/0~65535|
|`int32`, `uint32`|4|0|-21亿~21亿/0~42亿|
|`int64`, `uint64`|8|0||
|`float32`|4|0.0||
|`float64`|8|0.0||
|`complex64`|8|||
|`complex128`|8|||
|`uintptr`|4/8||以存储指针的`uint32`或`uint64`整数|
|array|||值类型|
|`string`||`""`|值类型|
|`struct`|||值类型|
|slice||`nil`|引用类型|
|`map`||`nil`|引用类型|
|channel（`chan`）||`nil`|引用类型|
|`interface`||`nil`|接口|
|function（`func`）||`nil`|函数|

***TODO***

## 数组

***TODO***

## Slice（切片）

切片的底层结构：

```go
type slice struct {
  array unsafe.Pointer // 指向数组的指针
  len int // 长度
  cap int // 容量
}
```

**创建切片**

- `make()`：***TODO***
- 空切片：***TODO***

**切片扩容**

***TODO***

**切片拷贝**

***TODO***

## 指针

***TODO***

## Map

无序键值对的集合，通过key进行快速检索，可以像迭代数组和切片那样进行迭代，但由于map无序，所以无法决定其返回顺序。

定义map：

- `make()`：`map_v := make(map[key_type]value_type)`
- `map`：`var map_v map[key_type]value_type`

_若不初始化map则会创建一个nil map，nil map不能用于存放键值对。_

`delete(map, key)`：删除键值对

## 错误处理

`error`接口
```go
type error interface {
  Error() string
}
```

只要实现了`Error()`方法就是实现了`error`接口。据此可自定义error。

### Panic

Panic（运行时恐慌）只会在程序运行时才抛出来的异常，在panic被抛出之后，若未在程序中添加任何保护措施，程序会打印出panic的详情并终止运行。如果一个panic是无意间引发的，其中的值只能由Go语言运行时指定，但当使用`panic()`有意引发一个panic时，可以自行指定其包含的值。

**从panic被引发到程序终止运行的大概过程**

某个函数中的某行代码引发一个panic后，初始的panic详情会被建立起来，并且该程序的控制器会立即从此行代码转移到调用其所属函数的那行代码上（调用栈中的上一级），此行代码所属函数的执行随即终止。紧接着，控制权并不会在此有片刻停留，它又会立即转移至上一级的调用代码处，反方向传播直至最外层函数（go函数，对于主协程来说就是`main()`）。但控制器亦不会停留在那里，而是被Go语言运行时系统收回。随后程序崩溃并终止运行，承载程序此次运行的进程亦随之死亡而消失。与此同时，在控制器传播过程中，panic详情会积累和完善，并在程序终止前打印出来。

**panic应该包含的值**

***TODO***

## 面向对象

三大基本特征：

- 封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式
- 继承：使得子类具有父类的属性和方法或者重新定义、追加属性和方法等
- 多态：不同对象中同种行为的不同实现方式

Go使用结构体对属性进行封装。相关概念：

- 方法：作用在接收者上的一个函数，接收者是某种类型的变量。方法格式：

  ```go
  func (recv receiver_type) method(parameter_list) (return_value_list) {}
  ```

- 访问权限：通过字母大小写控制可见性，大写字母开头表示可被其他包访问和使用，小写字母开头表示仅限包内使用

- 继承：在结构体内部内嵌匿名类型，此时匿名字段上的方法晋升成外层类型的方法

  > 匿名类型：无显式的变量名，如
  >
  > ```go
  > type Class struct {
  >   Parent
  > }
  > ```

- 多态：可以使用接口实现

## 泛型

_注：1.18版本之后支持泛型。该版本将于2022年2月发布。_

## CGo

***TODO***

## 包依赖管理

使用`package`关键字定义包，Go规定`main()`须在`main`包下。在同一个包内定义的函数、类型、变量、常量、所有文件下的代码都可随意访问，属于包内公开。

引入包使用`import`关键字。编译器会根据`import`指定的相对路径去搜索包然后导入，这个相对路径是从`GOROOT`或`GOPATH`下的`src`下开始搜索。Go总是先从`GOROOT`出发搜索，再从`GOPATH`列出的路径顺序中搜索，只要一搜到合适的包就停止搜索，当搜索完成仍搜不到包则报错。

如果导入的包重名，则可以进行别名导入，添加一个名称属性为包设置一个别名，如果不想在访问包属性时加上包名则可以为其设置特殊别名`.`，如

```go
import (
  . "fmt"
)
func main() {
  Println() // 此时不能再加上包名“fmt”
}
```

Go要求`import`导包必须在后续中使用，否则报错，若想避免此错误可以在包前加下划线，此为匿名导入，表示无法再访问其内部属性。

> 下划线`_`：又称blank identifier，可以用于赋值时弃值，可用于保留`import`时的包，还可用于丢弃函数的返回值。

导入匿名包时会进行一些初始化操作（如`init()`），如果这个初始化操作会影响当前包，则此匿名导入有意义。

### 远程包

Go集成了从Git上获取远程代码的能力。可以使用`get`子命令进行远程导包。在`import`语句中可以使用，首先从`GOPATH`中搜索路径，搜不到包就调用`go get`远程拉取导入。

### init函数

`init()`经常用来初始化环境、安装包或其他需要在程序启动之前先执行的操作。每个包中都可以定义`init()`，甚至可以定义多个，但建议每个包只定义一个。每次导包时在导入完成后且变量、常量等声明初始化完成后将会调用这个包的`init()`。

对于`main`包，如果定义了`init()`，则其会在`main()`之前执行，之后立即执行`main()`。

### Go Module

模块是存储在文件树中的Go包的集合，其根目录中包含`go.mod`文件，此文件定义了模块的模块路径，它也是用于根目录的导入路径，以及它的依赖性要求，每个依赖性要求都被写为模块路径和特定语义版本。

从1.11始，Go允许在`$GOPATH/src`以外的任何目录使用`go.mod`创建项目。相关命令：

- `go mod init`：初始化`go.mod`
- `go list`：列出依赖
- `go mod edit`：修改依赖
- `go mod tidy`：移除不需要的依赖

## 测试

***TODO***