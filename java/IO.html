<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>输入输出 - Notes</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">README</a></li><li class="chapter-item expanded "><a href="../basis.html"><strong aria-hidden="true">1.</strong> 基础</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basis/DataStructuresAndAlgorithms.html"><strong aria-hidden="true">1.1.</strong> 数据结构与算法</a></li><li class="chapter-item expanded "><a href="../basis/OS.html"><strong aria-hidden="true">1.2.</strong> 操作系统</a></li><li class="chapter-item expanded "><a href="../basis/Network.html"><strong aria-hidden="true">1.3.</strong> 计算机网络</a></li><li class="chapter-item expanded "><a href="../basis/Project.html"><strong aria-hidden="true">1.4.</strong> 项目管理</a></li></ol></li><li class="chapter-item expanded "><a href="../java.html"><strong aria-hidden="true">2.</strong> Java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../java/JavaSE.html"><strong aria-hidden="true">2.1.</strong> 基础</a></li><li class="chapter-item expanded "><a href="../java/Collections.html"><strong aria-hidden="true">2.2.</strong> 集合</a></li><li class="chapter-item expanded "><a href="../java/Concurrent.html"><strong aria-hidden="true">2.3.</strong> 并发</a></li><li class="chapter-item expanded "><a href="../java/JVM.html"><strong aria-hidden="true">2.4.</strong> 虚拟机</a></li><li class="chapter-item expanded "><a href="../java/IO.html" class="active"><strong aria-hidden="true">2.5.</strong> 输入输出</a></li><li class="chapter-item expanded "><a href="../java/Frameworks.html"><strong aria-hidden="true">2.6.</strong> 框架</a></li><li class="chapter-item expanded "><a href="../java/DesignPatterns.html"><strong aria-hidden="true">2.7.</strong> 设计模式</a></li><li class="chapter-item expanded "><a href="../java/BigData.html"><strong aria-hidden="true">2.8.</strong> 大数据</a></li></ol></li><li class="chapter-item expanded "><a href="../database/Database.html"><strong aria-hidden="true">3.</strong> 数据库</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../database/SQL.html"><strong aria-hidden="true">3.1.</strong> SQL</a></li><li class="chapter-item expanded "><a href="../database/MySQL.html"><strong aria-hidden="true">3.2.</strong> MySQL</a></li></ol></li><li class="chapter-item expanded "><a href="../Linux.html"><strong aria-hidden="true">4.</strong> Linux</a></li><li class="chapter-item expanded "><a href="../go.html"><strong aria-hidden="true">5.</strong> Go</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../go/Go.html"><strong aria-hidden="true">5.1.</strong> 基础</a></li><li class="chapter-item expanded "><a href="../go/Goroutine.html"><strong aria-hidden="true">5.2.</strong> 协程</a></li></ol></li><li class="chapter-item expanded "><a href="../frontend.html"><strong aria-hidden="true">6.</strong> 前端</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../frontend/HTML&CSS.html"><strong aria-hidden="true">6.1.</strong> HTML &amp; CSS</a></li><li class="chapter-item expanded "><a href="../frontend/Browser.html"><strong aria-hidden="true">6.2.</strong> 浏览器</a></li></ol></li><li class="chapter-item expanded "><a href="../android.html"><strong aria-hidden="true">7.</strong> 安卓</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../android/Activity.html"><strong aria-hidden="true">7.1.</strong> 活动</a></li><li class="chapter-item expanded "><a href="../android/System.html"><strong aria-hidden="true">7.2.</strong> 系统</a></li></ol></li><li class="chapter-item expanded "><a href="../others.html"><strong aria-hidden="true">8.</strong> 其他</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../others/Distributed.html"><strong aria-hidden="true">8.1.</strong> 分布式</a></li><li class="chapter-item expanded "><a href="../others/Server.html"><strong aria-hidden="true">8.2.</strong> 服务器</a></li><li class="chapter-item expanded "><a href="../others/Middleware.html"><strong aria-hidden="true">8.3.</strong> 中间件</a></li><li class="chapter-item expanded "><a href="../others/Docker.html"><strong aria-hidden="true">8.4.</strong> Docker</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="io"><a class="header" href="#io">I/O</a></h1>
<p>Java I/O分类：</p>
<ul>
<li>
<p>按功能来分：输入流、输出流</p>
</li>
<li>
<p>按类型来分：</p>
<ul>
<li>字节流：<code>InputStream</code>/<code>OutputStream</code>是字节流的抽象类，二者又派生出若干子类，不同子类分别处理不同的操作类型，按8位传输，以字节为单位输入输出数据</li>
<li>字符流：<code>Reader</code>/<code>Writer</code>是字符流的抽象类，二者亦派生出若干子类，不同子类分别处理不同的操作类型，按16位传输，以字符为单位输入输出数据</li>
</ul>
<p><em>注：无论是文件读写还是网络发送接收，信息的最小存储单元都是字节。</em></p>
</li>
</ul>
<p><strong>IO操作为何需要手动关闭？</strong></p>
<p>使用完IO流需要手动回收，这是为了节约系统资源。一般来说，需要手动关闭的都是用了虚拟机之外的资源，如端口、文件等，虚拟机无法通过垃圾回收释放这些资源，只能显式调用关闭方法来释放。调用<code>finalize()</code>方法虽然可以释放非Java资源，但是该方法的执行时机是在GC之前，而GC具有时间不确定性，所以<code>finalize()</code>执行时间亦不具确定性，对于需要及时回收的资源此方法无法保证及时，另外<code>finalize()</code>不是析构函数，JVM不能保证<code>finalize()</code>一定会执行，不能依赖<code>finalize()</code>来释放资源。</p>
<p>许多情况下，如果在一些比较频繁的操作中，不对流进行关闭，很容易出现输入输出流已经超越了JVM边界，所以有时候可能无法回收资源，所以流操作的时候凡是跨出虚拟机边界的资源都要求程序员自己关闭，不要指望垃圾回收。</p>
<h2 id="bio"><a class="header" href="#bio">BIO</a></h2>
<p>阻塞IO（Blocking IO）：数据的读取和写入须阻塞在一个线程内等待其完成。由于同步阻塞，因此新请求来时只能通过新建线程的方式来接受请求，导致系统占用资源大，或是线程堆栈溢出。可以通过线程池来优化，不过在并发量增加时会导致线程数量急剧膨胀。</p>
<h2 id="nio"><a class="header" href="#nio">NIO</a></h2>
<p>非阻塞IO（Non-blocking IO）：BIO面向流，而NIO面向缓冲区，任何时候访问NIO的数据，都是面向缓冲区的，最常用的缓冲区是<code>ByteBuffer</code>。</p>
<ul>
<li>Channel（通道）：NIO使用通道进行读写，通道是双向的，可读可写</li>
<li>Selector（选择器）：用于使用单线程处理多个通道</li>
</ul>
<h2 id="io多路复用"><a class="header" href="#io多路复用">IO多路复用</a></h2>
<p>一种同步IO模型，实现一个线程可以监听多个文件句柄，一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作，没有文件句柄就绪就会阻塞应用程序，交出CPU。</p>
<p><em>注：多路是指网络连接，复用是指同一个线程。</em></p>
<h3 id="selectpoll"><a class="header" href="#selectpoll">Select/Poll</a></h3>
<pre><code class="language-c">// select
int select(int max_fd, fd_set *readset, fd_set *writeset, fd_set *exceptset, struct timeval *timeout);
typedef struct {
  unsigned long fds_bits[__FDSET_LONGS];
} fd_set;
FD_ZERO(int fd, fd_set *fds);   // 清空集合
FD_SET(int fd, fd_set *fds);    // 将给定的描述符加入集合
FD_ISSET(int fd, fd_set *fds);  // 判断指定描述符是否在集合中
FD_CLR(int fd, fd_set *fds);    // 将给定的描述符从文件中删除
// poll
int poll(struct pollfd fds[], nfds_t nfds, int timeout);
struct pollfd {
  int fd;
  short events;
  short revents;
};
</code></pre>
<p><code>select()</code>底层是一个<code>fd_set</code>的数据结构，本质上是一个long类型数组，数组中的每一个元素都对应于一个文件描述符，通过轮询所有的文件描述符来检查是否有事件发生。<code>poll()</code>与<code>select()</code>差不多，但<code>poll()</code>的文件描述符无最大数量限制，但是依旧采用轮询遍历的方式检查是否有事件发生。</p>
<p>优点：</p>
<ol>
<li>可移植性好</li>
<li>连接数少且连接都十分活跃的情况下效率不错</li>
</ol>
<p>缺点：</p>
<ol>
<li>单个进程所打开的fd是有限的，通过<code>FD_SETSIZE</code>处理，默认1024（<code>select()</code>有此限制，<code>poll()</code>无最大连接数限制）</li>
<li>每次调用<code>select()</code>，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</li>
<li>对socket扫描时是线性扫描，采用轮询的方法，效率较低（高并发）</li>
</ol>
<h3 id="epoll"><a class="header" href="#epoll">Epoll</a></h3>
<pre><code class="language-c">typedef union epoll_data {
  void *ptr;
  int fd;
  uint32_t u32;
  uint64_t u64;
} epoll_data_t;
struct epoll_event {
  uint32_t events;
  epoll_data_t data;
};
int epoll_create(int size);
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
int epoll_wait(int epfd, struct epoll_event *event, int maxevents, int timeout);
</code></pre>
<p>Epoll是一种更高效的IO多路复用的方式，它可以监视的文件描述符数量突破了1024的限制，同时不需要通过轮询遍历的方式去检查文件描述符上是否有事件发生，因为<code>epoll_wait()</code>返回的就是有事件发生的文件描述符。Epoll本质上是事件驱动。</p>
<p>Epoll具体是通过红黑树和就绪链表实现的，红黑树存储所有的文件描述符，就绪链表存储有事件发生的文件描述符；<code>epoll_ctl()</code>可以对文件描述符结点进行增删改查，并告知内核注册回调函数（事件），一旦文件描述符上有事件发生时，内核将该文件描述符结点插入到就绪链表里面，这时<code>epoll_wait()</code>将会接收到消息，并且将数据拷贝到用户空间。</p>
<p>表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</p>
<h4 id="水平触发边缘触发"><a class="header" href="#水平触发边缘触发">水平触发&amp;边缘触发</a></h4>
<ul>
<li>
<p>水平触发（LT）：一个事件只要有，就会一直触发</p>
<ul>
<li>Socket接收缓冲区不为空，有数据可读，读事件一直触发</li>
<li>Socket发送缓冲区不满，可以继续写入数据，写事件一直触发</li>
</ul>
<p>处理过程：</p>
<ul>
<li>Accept一个连接，添加到epoll中监听<code>EPOLLIN</code>事件</li>
<li>当<code>EPOLLIN</code>事件到达时，读<code>fd</code>中的数据并处理</li>
<li>当需要写出数据时，把数据写到<code>fd</code>中，若数据较大，无法一次性写出，则在epoll中监听<code>EPOLLOUT</code>事件</li>
<li>当<code>EPOLLOUT</code>事件到达时，继续把数据写到<code>fd</code>中，若数据写出完毕，则在epoll中关闭<code>EPOLLOUT</code>事件</li>
</ul>
<p>LT的处理过程中，直到返回<code>EAGAIN</code>不是硬性要求，但通常的处理过程都会读写直到返回<code>EAGAIN</code>，但LT比ET多了个开关<code>EPOLLOUT</code>事件的步骤。LT的编程与<code>poll()</code>/<code>select()</code>接近，符合一直以来的习惯，不易出错。</p>
</li>
<li>
<p>边缘触发（ET）：只有一个事件从无到有才会触发</p>
<ul>
<li>Socket的接收缓冲区状态变化时触发读事件，即空的接收缓冲区刚接收到数据时触发读事件</li>
<li>Socket的发送缓冲区状态变化时触发写事件，即满的缓冲区刚空出空间时触发写事件</li>
</ul>
<p>处理过程：</p>
<ul>
<li>Accept一个连接，添加到epoll中监听<code>EPOLLIN|EPOLLOUT</code>事件</li>
<li>当<code>EPOLLIN</code>事件到达时，读<code>fd</code>中的数据并处理，<code>read()</code>需一直读，直到返回<code>EAGAIN</code>为止</li>
<li>当需要写出数据时，把数据写到<code>fd</code>中，直到数据全部写完，或者<code>write()</code>返回<code>EAGAIN</code></li>
<li>当<code>EPOLLOUT</code>事件到达时，继续把数据写到<code>fd</code>中，直到数据全部写完，或者<code>write()</code>返回<code>EAGAIN</code></li>
</ul>
<p><em>仅在状态变化时触发。</em></p>
<p>ET的要求是一直读写，直到返回<code>EAGAIN</code>，否则就会遗漏事件。ET的编程可以做到更加简洁，某些场景下更加高效，但一方面容易遗漏事件，产生错误（如<code>EPOLLIN</code>时要循环读至<code>EAGAIN</code>，如果在读的<code>fd</code>一直有数据到来，会造成其他描述符饥饿）。</p>
</li>
</ul>
<h3 id="reactor模型"><a class="header" href="#reactor模型">Reactor模型</a></h3>
<p>Reactor模型要求主线程只负责监听文件描述上是否有事件发生，有的话立即将该事件通知给工作线程，除此之外，主线程不做任何其他实质性的工作，读写数据、接收新的连接以及处理客户请求均在工作线程上完成。</p>
<p>Reactor模型主要包含两个组件：</p>
<ul>
<li>Reactor：负责查询、响应IO事件，当检测到IO事件时，分发给Handlers处理；</li>
<li>Handler：与IO事件绑定，负责IO事件的处理。</li>
</ul>
<p>包含几种实现方式：</p>
<ol>
<li>单线程单Reactor：该模式Reactor和Handler在同一线程中，若某个Handler阻塞会导致其他Handler无法执行，且无法充分利用多核的性能</li>
<li>多线程单Reactor：由于decode、compute、encode操作并非IO操作，多线程单Reactor思路就是充分发挥多核的特性，同时把非IO的操作剥离开，但由于单个Reactor承担了所有的事件监听、响应工作，若连接过多还是有可能存在性能问题</li>
<li>多线程多Reactor：为了解决单Reactor的性能问题产生的多Reactor模式，其中mainReactor建立连接，多个subReactor负责数据读写</li>
</ol>
<h2 id="aio"><a class="header" href="#aio">AIO</a></h2>
<p>异步：当一个异步过程被调用后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。与同步相对。</p>
<p>异步IO（Asynchronized IO）：基于事件和回调机制实现</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../java/JVM.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../java/Frameworks.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../java/JVM.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../java/Frameworks.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
